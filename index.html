<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-我的第一篇博客文章" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" class="article-date">
  <time class="dt-published" datetime="2023-04-22T03:17:18.000Z" itemprop="datePublished">2023-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">我的第一篇博客文章</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" data-id="clgreyi3j0000p8vt17xgdlt5" data-title="我的第一篇博客文章" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/22/hello-world/" class="article-date">
  <time class="dt-published" datetime="2023-04-22T03:08:10.290Z" itemprop="datePublished">2023-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/22/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/22/hello-world/" data-id="clgreyi3p0001p8vt9bfu1q66" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-GDB调试命令详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/16/GDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-03-16T08:09:41.000Z" itemprop="datePublished">2021-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/16/GDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">GDB调试命令详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="GDB是什么"><a href="#GDB是什么" class="headerlink" title="GDB是什么"></a>GDB是什么</h2><h3 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h3><p>程序中出现的语法错误可以借助编译器解决；但逻辑错误则只能靠自己解决。实际场景中解决逻辑错误最高效的方法，就是借助调试工具对程序进行调试。</p>
<p>所谓调试（Debug），就是让代码一步一步慢慢执行，跟踪程序的运行过程。比如，可以让程序停在某个地方，查看当前所有变量的值，或者内存中的数据；也可以让程序一次只执行一条或者几条语句，看看程序到底执行了哪些代码。</p>
<p>也就是说，通过调试程序，我们可以监控程序执行的每一个细节，包括变量的值、函数的调用过程、内存中数据、线程的调度等，从而发现隐藏的错误或者低效的代码。</p>
<h3 id="GDB的作用"><a href="#GDB的作用" class="headerlink" title="GDB的作用"></a>GDB的作用</h3><p><code>GDB</code> 全称“GNU symbolic debugger”，从名称上不难看出，它诞生于 <code>GNU</code> 计划（同时诞生的还有 GCC、Emacs 等），是 <code>Linux</code> 下常用的程序调试器。发展至今，<code>GDB</code> 已经迭代了诸多个版本，当下的 <code>GDB</code> 支持调试多种编程语言编写的程序，包括 <code>C、C++、Go、Objective-C、OpenCL、Ada</code>等。实际场景中，<code>GDB</code> 更常用来调试 <code>C</code> 和 <code>C++ </code>程序。</p>
<p>总的来说，借助 <code>GDB</code>调试器可以实现以下几个功能：</p>
<p>程序启动时，可以按照我们自定义的要求运行程序，例如设置参数和环境变量；</p>
<p>可使被调试程序在指定代码处暂停运行，并查看当前程序的运行状态（例如当前变量的值，函数的执行结果等），即支持断点调试；</p>
<p>程序执行过程中，可以改变某个变量的值，还可以改变代码的执行顺序，从而尝试修改程序中出现的逻辑错误。</p>
<h3 id="GDB安装"><a href="#GDB安装" class="headerlink" title="GDB安装"></a>GDB安装</h3><p>1、通过包管理器进行安装</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install gdb</span><br></pre></td></tr></table></figure>
<p>2、源码安装GDB</p>
<p>在<a target="_blank" rel="noopener" href="http://ftp.gnu.org/gnu/gdb/">gdb源码包</a>上面下载相应的版本进行安装即可。</p>
<p>3、查看GDB版本</p>
<p>输入<code>gdb -v</code>,即可查看当前安装的<code>gdb</code>的版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gdb -<span class="function">v</span></span><br><span class="line"><span class="function">GNU <span class="title">gdb</span> <span class="params">(GDB)</span> Red Hat Enterprise Linux 7.6.1-94.el7</span></span><br><span class="line"><span class="function"><span class="title">Copyright</span> <span class="params">(C)</span> 2013 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="function">License GPLv3+: GNU GPL version <span class="number">3</span> or later &lt;http://gnu.org/licenses/gpl.html&gt;</span></span><br><span class="line"><span class="function">This is free software: you are free to change and redistribute it.</span></span><br><span class="line"><span class="function">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">&quot;show copying&quot;</span></span></span><br><span class="line"><span class="function">and <span class="string">&quot;show warranty&quot;</span> for details.</span></span><br><span class="line"><span class="function">This GDB was configured as <span class="string">&quot;x86_64-redhat-linux-gnu&quot;</span>.</span></span><br><span class="line"><span class="function">For bug reporting instructions, please see:</span></span><br><span class="line"><span class="function">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span></span><br></pre></td></tr></table></figure>
<p>如果显示出<code>gdb</code>的版本，也说明了安装成功。</p>
<h2 id="GDB的用法"><a href="#GDB的用法" class="headerlink" title="GDB的用法"></a>GDB的用法</h2><h3 id="常用调试命令"><a href="#常用调试命令" class="headerlink" title="常用调试命令"></a>常用调试命令</h3><p><code>GDB</code> 的主要功能就是监控程序的执行流程。这也就意味着，只有当源程序文件编译为可执行文件并执行时，并且该文件中必须包含必要的调试信息（比如各行代码所在的行号、包含程序中所有变量名称的列表（又称为符号表）等），<code>GDB </code>才会派上用场。</p>
<p>所以在编译时需要使用 <code>gcc/g++ -g</code> 选项编译源文件，才可生成满足 <code>GDB</code> 要求的可执行文件</p>
<table>
<thead>
<tr>
<th>调试命令 (缩写)</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>(gdb) break (b)</td>
<td>在源代码指定的某一行设置断点，其中xxx用于指定具体打断点位置</td>
</tr>
<tr>
<td>(gdb) run (r)</td>
<td>执行被调试的程序，其会自动在第一个断点处暂停执行。</td>
</tr>
<tr>
<td>(gdb) continue (c)</td>
<td>当程序在某一断点处停止后，用该指令可以继续执行，直至遇到断点或者程序结束。</td>
</tr>
<tr>
<td>(gdb) next (n)</td>
<td>令程序一行代码一行代码的执行。</td>
</tr>
<tr>
<td>(gdb) step（s）</td>
<td>如果有调用函数，进入调用的函数内部；否则，和 next 命令的功能一样。</td>
</tr>
<tr>
<td>(gdb) until (u) <br/>(gdb) until (u) location</td>
<td>当你厌倦了在一个循环体内单步跟踪时，单纯使用 until 命令，可以运行程序直到退出循环体。<br/>until n 命令中，n 为某一行代码的行号，该命令会使程序运行至第 n 行代码处停止。</td>
</tr>
<tr>
<td>(gdb) print (p)</td>
<td>打印指定变量的值，其中 xxx 指的就是某一变量名。</td>
</tr>
<tr>
<td>(gdb) list (l)</td>
<td>显示源程序代码的内容，包括各行代码所在的行号。</td>
</tr>
<tr>
<td>(gdb) finish（fi）</td>
<td>结束当前正在执行的函数，并在跳出函数后暂停程序的执行。</td>
</tr>
<tr>
<td>(gdb) return（return）</td>
<td>结束当前调用函数并返回指定值，到上一层函数调用处停止程序执行。</td>
</tr>
<tr>
<td>(gdb) jump（j)</td>
<td>使程序从当前要执行的代码处，直接跳转到指定位置处继续执行后续的代码。</td>
</tr>
<tr>
<td>(gdb) quit (q)</td>
<td>终止调试。</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">main.cpp</span><br><span class="line">$ g++ -g -o test main.cpp</span><br><span class="line">$ ls</span><br><span class="line">main.cpp  test</span><br><span class="line">$ gdb test         &lt;-- 启动gdb进行调试</span><br><span class="line"><span class="function">GNU <span class="title">gdb</span> <span class="params">(GDB)</span> Red Hat Enterprise Linux 7.6.1-94.el7</span></span><br><span class="line"><span class="function"><span class="title">Copyright</span> <span class="params">(C)</span> 2013 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="function">License GPLv3+: GNU GPL version <span class="number">3</span> or later &lt;http://gnu.org/licenses/gpl.html&gt;</span></span><br><span class="line"><span class="function">This is free software: you are free to change and redistribute it.</span></span><br><span class="line"><span class="function">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">&quot;show copying&quot;</span></span></span><br><span class="line"><span class="function">and <span class="string">&quot;show warranty&quot;</span> for details.</span></span><br><span class="line"><span class="function">This GDB was configured as <span class="string">&quot;x86_64-redhat-linux-gnu&quot;</span>.</span></span><br><span class="line"><span class="function">For bug reporting instructions, please see:</span></span><br><span class="line"><span class="function">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span></span><br><span class="line"><span class="function">Reading symbols from /home/zhuyong/project/linux/blog/gdb/test...done.</span></span><br><span class="line"><span class="function">(gdb)</span></span><br></pre></td></tr></table></figure>
<p><code>gdb</code>启动时会默认打印一堆免责条款，通过添加 <code>--silent</code>（或者 <code>-q</code>、<code>--quiet</code>）选项，可将这部分信息屏蔽掉。</p>
<p>下面先用个例子运行下上述调试命令</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ gdb test -q      &lt;-- 启动gdb进行调试</span><br><span class="line">Reading symbols from /home/zhudi/project/linux/blog/gdb/test...done.</span><br><span class="line">(gdb) l            &lt;-- 显示带行号的源代码</span><br><span class="line"><span class="number">1</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="number">2</span>	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span>	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">5</span>	    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="number">6</span>	    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="number">7</span>	    <span class="keyword">while</span> (n &lt;= <span class="number">100</span>) &#123;</span><br><span class="line"><span class="number">8</span>	        sum += n;</span><br><span class="line"><span class="number">9</span>	        n++;</span><br><span class="line"><span class="number">10</span>	    &#125;</span><br><span class="line">(gdb)              &lt;-- 默认情况下，l 选项只显示 <span class="number">10</span> 行源代码，如果查看后续代码，按 Enter 回车键即可</span><br><span class="line"><span class="number">11</span>	    cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span>	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">14</span>	&#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line">(gdb) b <span class="number">7</span>          &lt;-- 在第<span class="number">7</span>行源代码处打断点</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x4008d3</span>: file main.cpp, line <span class="number">7.</span></span><br><span class="line">(gdb) r            &lt;-- 运行程序，遇到断点停止</span><br><span class="line">Starting program: /home/zhudi/project/linux/blog/gdb/test</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">7</span></span><br><span class="line"><span class="number">7</span>	    <span class="keyword">while</span> (n &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc<span class="number">-2.17</span><span class="number">-307.</span>el7<span class="number">.1</span>.x86_64 libgcc<span class="number">-4.8</span><span class="number">.5</span><span class="number">-39.</span>el7.x86_64 libstdc++<span class="number">-4.8</span><span class="number">.5</span><span class="number">-39.</span>el7.<span class="built_in">x86_64</span></span><br><span class="line">(gdb) print n      &lt;-- 查看代码中变量 n 的值</span><br><span class="line">$<span class="number">1</span> = <span class="number">1</span>             &lt;-- 当前 n 的值为 <span class="number">1</span>，$<span class="number">1</span> 表示该变量 表示该变量所在存储区的名称</span><br><span class="line">(gdb) b <span class="number">13</span></span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0x40090e</span>: file main.cpp, line <span class="number">13.</span></span><br><span class="line">(gdb) n            &lt;-- 单步执行程序</span><br><span class="line"><span class="number">8</span>	        sum += n;</span><br><span class="line">(gdb) n            &lt;-- 单步执行程序</span><br><span class="line"><span class="number">9</span>	        n++;</span><br><span class="line">(gdb) c            &lt;-- 继续执行程序</span><br><span class="line">Continuing.</span><br><span class="line">sum = <span class="number">5050</span></span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">2</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">13</span></span><br><span class="line"><span class="number">13</span>	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">(gdb) print sum     &lt;-- 查看 sum 的值    </span><br><span class="line">$<span class="number">2</span> = <span class="number">5050</span>           &lt;-- 当前 sum 的值为 <span class="number">5050</span></span><br><span class="line">(gdb) q             &lt;-- 退出调试</span><br><span class="line">A debugging session is active.</span><br><span class="line"></span><br><span class="line">	Inferior <span class="number">1</span> [process <span class="number">8449</span>] will be killed.</span><br><span class="line"></span><br><span class="line">Quit anyway? (y <span class="keyword">or</span> n) y     &lt;-- 确认是否退出调试，y 为退出，n 为不退出</span><br></pre></td></tr></table></figure>
<p>接下来分别介绍下各个命令的用法</p>
<h3 id="GDB-断点调试"><a href="#GDB-断点调试" class="headerlink" title="GDB 断点调试"></a>GDB 断点调试</h3><h4 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h4><p>根据不同场景的需要，<code>GDB</code> 调试器提供了多种方式来启动目标程序，其中最常用的就是<code> run</code> 指令，其次为 <code>start</code> 指令。也就是说，<code>run </code>和 <code>start</code> 指令都可以用来在 <code>GDB</code> 调试器中启动程序，它们之间的区别是：</p>
<ul>
<li><p>默认情况下，<code>run</code> 指令会一直执行程序，直到执行结束。如果程序中手动设置有断点，则 <code>run </code>指令会执行程序至第一个断点处；</p>
</li>
<li><p><code>start</code> 指令会执行程序至<code>main()</code>主函数的起始位置，即在<code>main()</code>函数的第一行语句处停止执行（该行代码尚未执行）。</p>
</li>
</ul>
<h4 id="break命令"><a href="#break命令" class="headerlink" title="break命令"></a>break命令</h4><p><code>break</code> 命令（可以用<code> b</code> 代替）常用的语法格式有以下 2 种。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、(gdb) <span class="keyword">break</span> location      <span class="comment">// b location</span></span><br><span class="line"><span class="number">2</span>、(gdb) <span class="keyword">break</span> ... <span class="keyword">if</span> cond   <span class="comment">// b .. if cond</span></span><br></pre></td></tr></table></figure>

<ol>
<li>第一种格式中，<code>location</code> 用于指定打断点的具体位置，其表示方式有多种，如表 1 所示。</li>
</ol>
<table>
<thead>
<tr>
<th>location的值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>linenum</td>
<td>linenum 是一个整数，表示要打断点处代码的行号。要知道，程序中各行代码都有对应的行号，可通过执行 l（小写的 L）命令看到。</td>
</tr>
<tr>
<td>filename:linenum</td>
<td>filename 表示源程序文件名；linenum 为整数，表示具体行数。整体的意思是在指令文件 filename 中的第 linenum 行打断点。</td>
</tr>
<tr>
<td>+ offset<br>- offset</td>
<td>offset 为整数（假设值为 2），+offset 表示以当前程序暂停位置（例如第 4 行）为准，向后数 offset 行处（第 6 行）打断点；-offset 表示以当前程序暂停位置为准，向前数 offset 行处（第 2 行）打断点</td>
</tr>
<tr>
<td>function</td>
<td>function 表示程序中包含的函数的函数名，即 break 命令会在该函数内部的开头位置打断点，程序会执行到该函数第一行代码处暂停。</td>
</tr>
<tr>
<td>filename:function</td>
<td>filename 表示远程文件名；function 表示程序中函数的函数名。整体的意思是在指定文件 filename 中 function 函数的开头位置打断点。</td>
</tr>
</tbody></table>
<ol start="2">
<li>第二种格式中，… 可以是表 1 中所有参数的值，用于指定打断点的具体位置；<code>cond</code> 为某个表达式。整体的含义为：每次程序执行到 … 位置时都计算 <code>cond</code> 的值，如果为 <code>True</code>，则程序在该位置暂停；反之，程序继续执行。另外也可以用<code>condition</code> 为断点设置命中条件。</li>
</ol>
<h4 id="tbreak和rbreak命令"><a href="#tbreak和rbreak命令" class="headerlink" title="tbreak和rbreak命令"></a>tbreak和rbreak命令</h4><p><code>tbreak</code> 命令可以看到是 break 命令的另一个版本，<code>tbreak</code> 和 <code>break</code> 命令的用法和功能都非常相似，唯一的不同在于，使用 <code>tbreak</code> 命令打的断点仅会作用 1 次，即使程序暂停之后，该断点就会自动消失。</p>
<p>和 <code>break</code> 和 <code>tbreak</code> 命令不同，<code>rbreak </code>命令的作用对象是 <code>C</code>、<code>C++</code> 程序中的函数，它会在指定函数的开头位置打断点。语法格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) tbreak regex</span><br></pre></td></tr></table></figure>

<p>其中 <code>regex</code> 为一个正则表达式，程序中函数的函数名只要满足 <code>regex </code>条件，<code>tbreak</code> 命令就会其内部的开头位置打断点。值得一提的是，<code>tbreak</code> 命令打的断点和 <code>break</code> 命令打断点的效果是一样的，会一直存在，不会自动消失。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">$ gdb test -q</span><br><span class="line">Reading symbols from /home/zhudi/project/linux/blog/gdb/test...done.</span><br><span class="line">(gdb) l</span><br><span class="line"><span class="number">4</span>	</span><br><span class="line"><span class="number">5</span>	<span class="function"><span class="type">void</span> <span class="title">cb_one</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">6</span>	    cout &lt;&lt; <span class="string">&quot;cb_one&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="number">7</span>	&#125;</span><br><span class="line"><span class="number">8</span>	<span class="function"><span class="type">void</span> <span class="title">cb_second</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">9</span>	    cout &lt;&lt; <span class="string">&quot;cb_second&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="number">10</span>	&#125;</span><br><span class="line"><span class="number">11</span>	</span><br><span class="line"><span class="number">12</span>	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">13</span>	    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">14</span>	    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="number">15</span>	    <span class="keyword">while</span> (sum &lt; <span class="number">100</span>) &#123;</span><br><span class="line"><span class="number">16</span>	        sum += n;</span><br><span class="line"><span class="number">17</span>	        n++;</span><br><span class="line"><span class="number">18</span>	        cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="number">19</span>	        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"><span class="number">20</span>	        <span class="built_in">cb_one</span>();</span><br><span class="line"><span class="number">21</span>	        <span class="built_in">cb_second</span>();</span><br><span class="line"><span class="number">22</span>	    &#125;</span><br><span class="line"><span class="number">23</span>	    cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">(gdb) b <span class="number">16</span>                  &lt;-- 在第<span class="number">16</span>行打断点</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x400959</span>: file main.cpp, line <span class="number">16.</span></span><br><span class="line">(gdb) r                     &lt;-- 启动程序</span><br><span class="line">Starting program: /home/zhudi/project/linux/blog/gdb/test </span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">16</span></span><br><span class="line"><span class="number">16</span>	        sum += n;       &lt;-- 在<span class="number">16</span>行暂停</span><br><span class="line">(gdb) b +<span class="number">2</span>                  &lt;--在当前位置之后的<span class="number">2</span>行处设置断点</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0x400963</span>: file main.cpp, line <span class="number">18.</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">2</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">18</span></span><br><span class="line"><span class="number">18</span>	        cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">(gdb) b <span class="number">19</span> <span class="keyword">if</span> sum&gt;<span class="number">2</span>         &lt;-- 条件断点</span><br><span class="line">Breakpoint <span class="number">3</span> at <span class="number">0x40098c</span>: file main.cpp, line <span class="number">19.</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">sum = <span class="number">1</span></span><br><span class="line">cb_one</span><br><span class="line">cb_second</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">16</span></span><br><span class="line"><span class="number">16</span>	        sum += n;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">2</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">18</span></span><br><span class="line"><span class="number">18</span>	        cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">sum = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">3</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">19</span></span><br><span class="line"><span class="number">19</span>	        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">(gdb) p sum</span><br><span class="line">$<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">(gdb) rbreak cb_*            &lt;-- 匹配所有以cb_开头的函数</span><br><span class="line">Breakpoint <span class="number">4</span> at <span class="number">0x400901</span>: file main.cpp, line <span class="number">6.</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">cb_one</span>();</span><br><span class="line">Breakpoint <span class="number">5</span> at <span class="number">0x400923</span>: file main.cpp, line <span class="number">9.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb_second</span><span class="params">()</span></span>;</span><br><span class="line">Breakpoint <span class="number">6</span> at <span class="number">0x400a17</span>: file main.cpp, line <span class="number">26.</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">4</span>, <span class="built_in">cb_one</span> () at main.cpp:<span class="number">6</span></span><br><span class="line"><span class="number">6</span>	    cout &lt;&lt; <span class="string">&quot;cb_one&quot;</span> &lt;&lt; endl;     &lt;-- 在cb_one函数的第一行暂停</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">cb_one</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">5</span>, <span class="built_in">cb_second</span> () at main.cpp:<span class="number">9</span></span><br><span class="line"><span class="number">9</span>	    cout &lt;&lt; <span class="string">&quot;cb_second&quot;</span> &lt;&lt; endl;  &lt;-- 在cb_second函数的第一行暂停</span><br></pre></td></tr></table></figure>

<h4 id="删除或禁用断点"><a href="#删除或禁用断点" class="headerlink" title="删除或禁用断点"></a>删除或禁用断点</h4><p><strong>删除断点</strong></p>
<p>如果之前建立的断点不再需要或者暂时不需要，该如何删除或者禁用呢？常用的方式有 2 种：</p>
<ol>
<li>使用 <code>quit</code> 命令退出调试，然后重新对目标程序启动调试，此方法会将消除上一次调试操作中建立的所有断点；</li>
<li>使用专门删除或禁用断点的命令，既可以删除某一个断点，也可以删除全部断点。</li>
</ol>
<p>无论是普通断点、观察断点还是捕捉断点，都可以使用 <code>clear</code> 或者 <code>delete</code> 命令进行删除。</p>
<p><code>clear</code> 命令可以删除指定位置处的所有断点，常用的语法格式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear location</span><br></pre></td></tr></table></figure>

<p>参数<code> location</code> 通常为某一行代码的行号或者某个具体的函数名。当 <code>location</code> 参数为某个函数的函数名时，表示删除位于该函数入口处的所有断点。</p>
<p><code>delete</code> 命令（可以缩写为 <code>d </code>）通常用来删除所有断点，也可以删除指定编号的各类型断点，语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [breakpoints] [num]</span><br></pre></td></tr></table></figure>

<p>其中，<code>breakpoints</code> 参数可有可无，<code>num</code> 参数为指定断点的编号，其可以是<code> delete</code> 删除某一个断点，而非全部。</p>
<p>如果不指定 <code>num </code>参数，则 <code>delete</code> 命令会删除当前程序中存在的所有断点。</p>
<p><strong>禁用断点</strong></p>
<p>禁用断点可以使用 <code>disable</code> 命令，语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable [breakpoints] [num...]</span><br></pre></td></tr></table></figure>

<p><code>breakpoints</code> 参数可有可无；<code>num... </code>表示可以有多个参数，每个参数都为要禁用断点的编号。如果指定 <code>num...</code>，<code>disable</code> 命令会禁用指定编号的断点；反之若不设定 <code>num...</code>，则 <code>disable</code> 会禁用当前程序中所有的断点。</p>
<p>对于禁用的断点，可以使用<code> enable</code> 命令激活，该命令的语法格式有多种，分别对应有不同的功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enable [breakpoints] [num...]                        激活用 num... 参数指定的多个断点，如果不设定 num...，表示激活所有禁用的断点</span><br><span class="line">enable [breakpoints] once num…                 临时激活以 num... 为编号的多个断点，但断点只能使用 <span class="number">1</span> 次，之后会自动回到禁用状态</span><br><span class="line">enable [breakpoints] count num...      临时激活以 num... 为编号的多个断点，断点可以使用 count 次，之后进入禁用状态</span><br><span class="line">enable [breakpoints] <span class="keyword">delete</span> num…               激活 num.. 为编号的多个断点，但断点只能使用 <span class="number">1</span> 次，之后会被永久删除。</span><br></pre></td></tr></table></figure>

<p>其中，<code>breakpoints</code> 参数可有可无；<code>num... </code>表示可以提供多个断点的编号，<code>enable </code>命令可以同时激活多个断点。</p>
<h3 id="观察断点监控变量值的变化"><a href="#观察断点监控变量值的变化" class="headerlink" title="观察断点监控变量值的变化"></a>观察断点监控变量值的变化</h3><h4 id="观察断点"><a href="#观察断点" class="headerlink" title="观察断点"></a>观察断点</h4><p>要知道，<code>GDB</code> 调试器支持在程序中打 3 种断点，分别为普通断点、观察断点和捕捉断点。其中 <code>break</code> 命令打的就是普通断点，而 <code>watch</code> 命令打的为观察断点。</p>
<p>使用 <code>GDB</code> 调试程序的过程中，借助观察断点可以监控程序中某个变量或者表达式的值，只要发生改变，程序就会停止执行。相比普通断点，观察断点不需要我们预测变量（表达式）值发生改变的具体位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch cond</span><br></pre></td></tr></table></figure>

<p>和 <code>watch</code> 命令功能相似的，还有 <code>rwatch</code> 和<code> awatch</code> 命令。其中：</p>
<ul>
<li><code>rwatch</code> 命令：只要程序中出现读取目标变量（表达式）的值的操作，程序就会停止运行；</li>
<li><code>awatch</code> 命令：只要程序中出现读取目标变量（表达式）的值或者改变值的操作，程序就会停止运行。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ gdb test -q</span><br><span class="line">Reading symbols from /home/zhudi/project/linux/blog/gdb/test...done.</span><br><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint <span class="number">1</span> at <span class="number">0x400949</span>: file main.cpp, line <span class="number">13.</span></span><br><span class="line">Starting program: /home/zhuyong/project/linux/blog/gdb/test </span><br><span class="line"></span><br><span class="line">Temporary breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">13</span></span><br><span class="line"><span class="number">13</span>	    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">(gdb) l</span><br><span class="line"><span class="number">8</span>	<span class="function"><span class="type">void</span> <span class="title">cb_second</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">9</span>	    cout &lt;&lt; <span class="string">&quot;cb_second&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="number">10</span>	&#125;</span><br><span class="line"><span class="number">11</span>	</span><br><span class="line"><span class="number">12</span>	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">13</span>	    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="number">14</span>	    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="number">15</span>	    <span class="keyword">while</span> (sum &lt; <span class="number">100</span>) &#123;</span><br><span class="line"><span class="number">16</span>	        sum += n;</span><br><span class="line"><span class="number">17</span>	        n++;</span><br><span class="line">(gdb) watch sum        &lt;-- 设置观察断点</span><br><span class="line">Hardware watchpoint <span class="number">2</span>: <span class="built_in">sum</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint <span class="number">2</span>: sum</span><br><span class="line"></span><br><span class="line">Old value = <span class="number">0</span></span><br><span class="line">New value = <span class="number">1</span></span><br><span class="line"><span class="built_in">main</span> () at main.cpp:<span class="number">17</span></span><br><span class="line"><span class="number">17</span>	        n++;       &lt;-- sum值发生变化，程序暂停</span><br></pre></td></tr></table></figure>

<h3 id="查看变量或表达式的值"><a href="#查看变量或表达式的值" class="headerlink" title="查看变量或表达式的值"></a>查看变量或表达式的值</h3><p>对于在调试期间查看某个变量或表达式的值，<code>GDB</code> 调试器提供有 2 种方法，即使用 <code>print</code> 命令或者 <code>display </code>命令。</p>
<h4 id="print-命令"><a href="#print-命令" class="headerlink" title="print 命令"></a>print 命令</h4><p>它的功能就是在 <code>GDB</code> 调试程序的过程中，输出或者修改指定变量或者表达式的值。</p>
<p><code>print</code> 命令可以缩写为 <code>p</code>，最常用的语法格式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="function">print <span class="title">num</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> p num</span></span><br></pre></td></tr></table></figure>

<p>其中，参数 <code>num</code> 用来代指要查看或者修改的目标变量或者表达式。</p>
<p>当程序中包含多个作用域不同但名称相同的变量或表达式时，可以借助<code>::</code>运算符明确指定要查看的目标变量或表达式。<code>::</code>运算符的语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="function">print <span class="title">file::variable</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> print function::variable</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>file </code>用于指定具体的文件名，<code>funciton</code> 用于指定具体所在函数的函数名，<code>variable </code>表示要查看的目标变量或表达式。</p>
<p>另外，<code>print</code>也可以打印出类或者结构体变量的值。</p>
<h4 id="display-命令"><a href="#display-命令" class="headerlink" title="display 命令"></a>display 命令</h4><p>和 <code>print</code> 命令一样，<code>display</code> 命令也用于调试阶段查看某个变量或表达式的值，它们的区别是，使用 <code>display</code> 命令查看变量或表达式的值，每当程序暂停执行（例如单步执行）时，<code>GDB</code> 调试器都会自动帮我们打印出来，而 <code>print</code> 命令则不会。</p>
<p>也就是说，使用 1 次 <code>print</code> 命令只能查看 1 次某个变量或表达式的值，而同样使用 1 次 <code>display</code> 命令，每次程序暂停执行时都会自动打印出目标变量或表达式的值。因此，当我们想频繁查看某个变量或表达式的值从而观察它的变化情况时，使用 <code>display</code> 命令可以一劳永逸。</p>
<p><code>display</code> 命令没有缩写形式，常用的语法格式如下 2 种：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="function">display <span class="title">expr</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> display/fmt expr</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，display 命令和 &#x2F;fmt 之间不要留有空格。以 &#x2F;x 为例，应写为 (gdb)display&#x2F;x expr。</p>
</blockquote>
<h3 id="GDB单步调试"><a href="#GDB单步调试" class="headerlink" title="GDB单步调试"></a>GDB单步调试</h3><p>根据实际场景的需要，<code>GDB</code> 调试器共提供了 3 种可实现单步调试程序的方法，即使用 <code>next</code>、<code>step</code> 和 <code>until</code> 命令。换句话说，这 3 个命令都可以控制 <code>GDB </code>调试器每次仅执行 1 行代码，但除此之外，它们各自还有不同的功能。</p>
<h4 id="next命令"><a href="#next命令" class="headerlink" title="next命令"></a>next命令</h4><p><code>next</code> 是最常用来进行单步调试的命令，其最大的特点是当遇到包含调用函数的语句时，无论函数内部包含多少行代码，<code>next</code> 指令都会一步执行完。也就是说，对于调用的函数来说，<code>next</code> 命令只会将其视作一行代码。</p>
<p><code>next</code> 命令可以缩写为<code> n</code> 命令，使用方法也很简单，语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) next count</span><br></pre></td></tr></table></figure>

<h4 id="step命令"><a href="#step命令" class="headerlink" title="step命令"></a>step命令</h4><p>通常情况下，<code>step</code> 命令和<code>next</code>命令的功能相同，都是单步执行程序。不同之处在于，当<code> step</code> 命令所执行的代码行中包含函数时，会进入该函数内部，并在函数第一行代码处停止执行。</p>
<p><code>step</code> 命令可以缩写为 <code>s </code>命令，用法和 <code>next</code> 命令相同，语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) step count</span><br></pre></td></tr></table></figure>

<h4 id="until命令"><a href="#until命令" class="headerlink" title="until命令"></a>until命令</h4><p><code>until</code> 命令可以简写为 <code>u</code> 命令，有 2 种语法格式，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、(gdb) until</span><br><span class="line"><span class="number">2</span>、(gdb) until location</span><br></pre></td></tr></table></figure>

<p>其中，参数 <code>location </code>为某一行代码的行号。</p>
<p>不带参数的 <code>until </code>命令，可以使 <code>GDB </code>调试器快速运行完当前的循环体，并运行至循环体外停止。注意，<code>until</code> 命令并非任何情况下都会发挥这个作用，只有当执行至循环体尾部（最后一行代码）时，<code>until </code>命令才会发生此作用；反之，<code>until </code>命令和 <code>next</code> 命令的功能一样，只是单步执行程序。</p>
<h4 id="return命令"><a href="#return命令" class="headerlink" title="return命令"></a>return命令</h4><p>实际调试时，在某个函数中调试一段时间后，可能不需要再一步步执行到函数返回处，希望直接执行完当前函数，这时可以使用 <code>finish </code>命令。与<code> finish</code> 命令类似的还有 <code>return</code> 命令，它们都可以结束当前执行的函数。</p>
<h4 id="finish命令"><a href="#finish命令" class="headerlink" title="finish命令"></a>finish命令</h4><p><code>finish</code> 命令和 <code>return </code>命令的区别是，<code>finish </code>命令会执行函数到正常退出；而 <code>return</code> 命令是立即结束执行当前函数并返回，也就是说，如果当前函数还有剩余的代码未执行完毕，也不会执行了。除此之外，<code>return </code>命令还有一个功能，即可以指定该函数的返回值。</p>
<h4 id="jump命令"><a href="#jump命令" class="headerlink" title="jump命令"></a>jump命令</h4><p><code>jump</code> 命令的功能是直接跳到指定行继续执行程序，其语法格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) jump location</span><br></pre></td></tr></table></figure>

<p>其中，<code>location</code> 通常为某一行代码的行号。</p>
<p>也就是说，<code>jump</code> 命令可以略过某些代码，直接跳到 <code>location </code>处的代码继续执行程序。这意味着，如果你跳过了某个变量（对象）的初始化代码，直接执行操作该变量（对象）的代码，很可能会导致程序崩溃或出现其它 <code>Bug</code>。另外，如果 <code>jump </code>跳转到的位置后续没有断点，那么 <code>GDB </code>会直接执行自跳转处开始的后续代码。</p>
<h3 id="GDB-search-命令"><a href="#GDB-search-命令" class="headerlink" title="GDB search 命令"></a>GDB search 命令</h3><p>调试文件时，某些时候可能会去找寻找某一行或者是某一部分的代码。可以使用 list 显示全部的源码，然后进行查看。当源文件的代码量较少时，我们可以使用这种方式搜索。如果源文件的代码量很大，使用这种方式寻找效率会很低。所以 <code>GDB </code>中提供了相关的源代码搜索的的<code>search</code>命令。</p>
<p><code>search</code> 命令的语法格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search &lt;regexp&gt;</span><br><span class="line">reverse-search &lt;regexp&gt;</span><br></pre></td></tr></table></figure>

<p>第一项命令格式表示从当前行的开始向前搜索，后一项表示从当前行开始向后搜索。其中<code> regexp</code> 就是正则表达式，正则表达式描述了一种字符串匹配的模式，可以用来检查一个串中是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串。很多的编程语言都支持使用正则表达式。</p>
<h3 id="查看堆栈信息"><a href="#查看堆栈信息" class="headerlink" title="查看堆栈信息"></a>查看堆栈信息</h3><h4 id="backtrace-命令"><a href="#backtrace-命令" class="headerlink" title="backtrace 命令"></a>backtrace 命令</h4><p><code>backtrace</code> 命令用于打印当前调试环境中所有栈帧的信息，常用的语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace [-full] [n]</span><br></pre></td></tr></table></figure>

<p>其中，用 [ ] 括起来的参数为可选项，它们的含义分别为：</p>
<ul>
<li><p><code>n</code>：一个整数值，当为正整数时，表示打印最里层的 <code>n</code> 个栈帧的信息；<code>n </code>为负整数时，那么表示打印最外层<code>n</code>个栈帧的信息；</p>
</li>
<li><p><code>-full</code>：打印栈帧信息的同时，打印出局部变量的值。</p>
</li>
</ul>
<p>注意，当调试多线程程序时，该命令仅用于打印当前线程中所有栈帧的信息。如果想要打印所有线程的栈帧信息，应执行<code>thread apply all backtrace</code>命令。</p>
<h4 id="frame-命令"><a href="#frame-命令" class="headerlink" title="frame 命令"></a>frame 命令</h4><p><code>frame </code>命令的常用形式有 2 个：</p>
<ol>
<li>根据栈帧编号或者栈帧地址，选定要查看的栈帧，语法格式如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) frame spec</span><br></pre></td></tr></table></figure>

<p>该命令可以将 <code>spec</code> 参数指定的栈帧选定为当前栈帧。<code>spec</code> 参数的值，常用的指定方法有 3 种：</p>
<ol>
<li>通过栈帧的编号指定。0 为当前被调用函数对应的栈帧号，最大编号的栈帧对应的函数通常就是 main() 主函数；</li>
<li>借助栈帧的地址指定。栈帧地址可以通过 <code>info frame</code> 命令（后续会讲）打印出的信息中看到；</li>
<li>通过函数的函数名指定。注意，如果是类似递归函数，其对应多个栈帧的话，通过此方法指定的是编号最小的那个栈帧。</li>
</ol>
<p>除此之外，对于选定一个栈帧作为当前栈帧，<code>GDB</code> 调试器还提供有<code> up</code> 和<code>down</code>两个命令。其中，<code>up </code>命令的语法格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) up n</span><br></pre></td></tr></table></figure>

<p>其中 <code>n </code>为整数，默认值为 1。该命令表示在当前栈帧编号（假设为 <code>m</code>）的基础上，选定 <code>m+n </code>为编号的栈帧作为新的当前栈帧。</p>
<p>相对地，<code>down</code> 命令的语法格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) down n</span><br></pre></td></tr></table></figure>

<p>其中<code>n</code>为整数，默认值为 1。该命令表示在当前栈帧编号（假设为 <code>m</code>）的基础上，选定<code> m-n</code> 为编号的栈帧作为新的当前栈帧。</p>
<ol start="2">
<li>借助如下命令，我们可以查看当前栈帧中存储的信息：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info frame</span><br></pre></td></tr></table></figure>

<p>该命令会依次打印出当前栈帧的如下信息：</p>
<ul>
<li>当前栈帧的编号，以及栈帧的地址；</li>
<li>当前栈帧对应函数的存储地址，以及该函数被调用时的代码存储的地址</li>
<li>当前函数的调用者，对应的栈帧的地址；</li>
<li>编写此栈帧所用的编程语言；</li>
<li>函数参数的存储地址以及值；</li>
<li>函数中局部变量的存储地址；</li>
<li>栈帧中存储的寄存器变量，例如指令寄存器（64位环境中用 rip 表示，32为环境中用<code> eip</code> 表示）、堆栈基指针寄存器（64位环境用 <code>rbp </code>表示，32位环境用 <code>ebp </code>表示）等。</li>
</ul>
<p>除此之外，还可以使用<code>info args</code>命令查看当前函数各个参数的值；使用<code>info locals</code>命令查看当前函数中各局部变量的值。</p>
<h3 id="调试正在执行的程序"><a href="#调试正在执行的程序" class="headerlink" title="调试正在执行的程序"></a>调试正在执行的程序</h3><p>如果调试正在执行中的程序，首先需要找到正在运行程序的进程号<code>PID</code>，之后可以用下面三个命令进行调试，进入正常的调试流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) gdb attach PID</span><br><span class="line"><span class="number">2</span>) gdb 文件名 PID</span><br><span class="line"><span class="number">3</span>) gdb -p PID</span><br></pre></td></tr></table></figure>

<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ps -aux | grep test           &lt;-- 找到正在运行程序的进程号PID</span></span><br><span class="line">root     <span class="number">17997</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">12540</span>  <span class="number">1064</span> pts/<span class="number">0</span>    S+   <span class="number">10</span>:<span class="number">19</span>   <span class="number">0</span>:<span class="number">00</span> ./test</span><br><span class="line">root     <span class="number">18088</span>  <span class="number">0.0</span>  <span class="number">0.0</span> <span class="number">112812</span>   <span class="number">972</span> pts/<span class="number">1</span>    S+   <span class="number">10</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> grep --color=<span class="keyword">auto</span> test</span><br><span class="line">    </span><br><span class="line"><span class="meta"># gdb attach 17997 -q           &lt;-- 用gdb进行调试</span></span><br><span class="line">attach: No such file <span class="keyword">or</span> directory.</span><br><span class="line">Attaching to process <span class="number">17997</span></span><br><span class="line">Reading symbols from /root/project/blog/gdb/test...done.</span><br><span class="line">Reading symbols from /lib64/libstdc++.so<span class="number">.6</span>...(no debugging symbols found)...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/libstdc++.so<span class="number">.6</span></span><br><span class="line">Reading symbols from /lib64/libm.so<span class="number">.6</span>...(no debugging symbols found)...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/libm.so<span class="number">.6</span></span><br><span class="line">Reading symbols from /lib64/libgcc_s.so<span class="number">.1</span>...(no debugging symbols found)...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/libgcc_s.so<span class="number">.1</span></span><br><span class="line">Reading symbols from /lib64/libc.so<span class="number">.6</span>...(no debugging symbols found)...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/libc.so<span class="number">.6</span></span><br><span class="line">Reading symbols from /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>...(no debugging symbols found)...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span></span><br><span class="line"><span class="number">0x00007f61ea02b840</span> in __nanosleep_nocancel () from /lib64/libc.so<span class="number">.6</span></span><br></pre></td></tr></table></figure>
<p>注意，当 <code>GDB</code> 调试器成功连接到指定进程上时，程序执行会暂停。如上所示，程序暂停至第 6 行代码<code>num++</code>的位置，此时可以通过断点调试、逐步运行等方式监控程序的执行过程。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l                        </span><br><span class="line">warning: Source file is more recent than executable.</span><br><span class="line"><span class="number">1</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="number">2</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="number">3</span>	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="number">4</span>	</span><br><span class="line"><span class="number">5</span>	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">6</span>	    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="number">7</span>	    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="number">8</span>	    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="number">9</span>	        sum += n;</span><br><span class="line"><span class="number">10</span>	        n++;</span><br><span class="line">(gdb) </span><br><span class="line"><span class="number">11</span>	        cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="number">12</span>	        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"><span class="number">13</span>	    &#125;</span><br><span class="line"><span class="number">14</span>	    cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="number">15</span>	</span><br><span class="line"><span class="number">16</span>	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">17</span>	&#125;</span><br><span class="line"><span class="number">18</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">(gdb) b <span class="number">10</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x400869</span>: file main.cpp, line <span class="number">10.</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">10</span></span><br><span class="line"><span class="number">10</span>	        n++;</span><br><span class="line">(gdb) p sum</span><br><span class="line">$<span class="number">1</span> = <span class="number">2145</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">10</span></span><br><span class="line"><span class="number">10</span>	        n++;</span><br><span class="line">(gdb) p sum</span><br><span class="line">$<span class="number">2</span> = <span class="number">2211</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>注意，当调试完成后，如果想令当前程序进行执行，消除调试操作对它的影响，需手动将 <code>GDB</code> 调试器与程序分离，分离过程分为 2 步：</p>
<ol>
<li><p>执行 <code>detach</code> 指令，使<code>GDB</code>调试器和程序分离；</p>
</li>
<li><p>执行 <code>quit</code>（或<code> q</code>）指令，退出<code>GDB</code>调试。</p>
</li>
</ol>
<h3 id="调试执行异常崩溃的程序"><a href="#调试执行异常崩溃的程序" class="headerlink" title="调试执行异常崩溃的程序"></a>调试执行异常崩溃的程序</h3><p>在<code>Linux</code>操作系统中，当程序执行发生异常崩溃时，系统可以将发生崩溃时的内存数据、调用堆栈情况等信息自动记录下载，并存储到一个文件中，该文件通常称为<code> core</code> 文件，<code>Linux</code> 系统所具备的这种功能又称为核心转储（<code>core dump</code>）。幸运的是，<code>GDB</code> 对<code> core</code> 文件的分析和调试提供有非常强大的功能支持，当程序发生异常崩溃时，通过<code> GDB</code> 调试产生的 <code>core </code>文件，往往可以更快速的解决问题。</p>
<p>这里就先不写如何设置<code>core dump</code>文件目录了，可以自行了解。</p>
<p>写个程序验证一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *a = <span class="literal">NULL</span>;</span><br><span class="line">    *a = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -g -o test core.cpp </span><br><span class="line">$ ./<span class="function">test</span></span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span>      &lt;-- 发生段错误，并生成了 core 文件</span></span><br></pre></td></tr></table></figure>

<p>可以根据生成时间查找<code>core dump</code>文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls /home/homework/coresave -hl | grep test</span><br><span class="line">-rw-rw-rw- <span class="number">1</span> root      root      <span class="number">400</span>K Mar <span class="number">13</span> <span class="number">15</span>:<span class="number">08</span> core.test<span class="number">.27725</span><span class="number">.1615619332</span></span><br><span class="line">-rw-rw-rw- <span class="number">1</span> root      root      <span class="number">400</span>K Mar <span class="number">13</span> <span class="number">15</span>:<span class="number">26</span> core.test<span class="number">.7791</span><span class="number">.1615620408</span></span><br><span class="line">-rw-rw-rw- <span class="number">1</span> root      root      <span class="number">540</span>K Mar <span class="number">11</span> <span class="number">10</span>:<span class="number">29</span> core.test<span class="number">.1868</span><span class="number">.1615429740</span></span><br><span class="line">-rw-rw-rw- <span class="number">1</span> root      root      <span class="number">400</span>K Mar <span class="number">13</span> <span class="number">15</span>:<span class="number">07</span> core.test<span class="number">.26880</span><span class="number">.1615619264</span></span><br><span class="line">-rw-rw-rw- <span class="number">1</span> root      root      <span class="number">404</span>K Mar  <span class="number">3</span> <span class="number">19</span>:<span class="number">42</span> core.test<span class="number">.28802</span><span class="number">.1614771771</span></span><br></pre></td></tr></table></figure>

<p>用<code>gdb</code>进行调试</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gdb test /home/homework/coresave/core.test1<span class="number">.7791</span><span class="number">.1615620408</span> -q</span><br><span class="line">Reading symbols from /home/zhudi/project/linux/blog/gdb/test...done.</span><br><span class="line"></span><br><span class="line">warning: core file may <span class="keyword">not</span> match specified executable file.</span><br><span class="line">[New LWP <span class="number">7791</span>]</span><br><span class="line">Core was generated by `./test<span class="number">&#x27;.</span></span><br><span class="line">Program terminated with signal <span class="number">11</span>, Segmentation fault.</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00000000004005bd</span> <span class="function">in <span class="title">main</span> <span class="params">()</span> at core.cpp:<span class="number">5</span></span></span><br><span class="line"><span class="function"><span class="number">5</span>	    *a =</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>由此可见，程序崩溃了在第五行，定位到了出现问题的代码位置。</p>
<p>本文参考</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/gdb/">GDB调试教程</a></p>
<html>
    <table style="margin-left:auto; margin-right: auto;">
        <tr>
            <td>
             <img src="https://i.loli.net/2021/02/03/SXE7MICDbUh9Q3J.jpg" width = "110" height = "110"/>
            </td>
            <td>
<span>本文作者</span>：<strong><span style="font-size: 15px;"><a href="https://github.com/zhuyongchn" target="_blank">zhuyong</a></span></strong> <br>
<span>原文链接</span>：<strong><span style="font-size: 15px;"><a href="https://zhuyongchn.github.io" target="_blank">https://zhuyongchn.github.io</a></span></strong> <br>
<span class="essaySuffix-right-title">关于博主</span>：欢迎关注左侧公众号，获取更多干货。<br>
<span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" alt="BY-NC-SA" title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！<br>
            </td>
        </tr>
    </table>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/16/GDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" data-id="clgrezjwk0000skvt6x0qbcs3" data-title="GDB调试命令详解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-webrtc sdp(会话传输协议)详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/08/webrtc%20sdp(%E4%BC%9A%E8%AF%9D%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-02-08T12:09:59.000Z" itemprop="datePublished">2021-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/08/webrtc%20sdp(%E4%BC%9A%E8%AF%9D%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)%E8%AF%A6%E8%A7%A3/">sdp(会话传输协议)详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="1、什么是sdp"><a href="#1、什么是sdp" class="headerlink" title="1、什么是sdp"></a>1、什么是sdp</h4><p>SDP(Session Description Protocol)描述会话协议，它只是一种信息格式的描述标准，本身不属于传输协议，但是可以被其他传输协议用来交换必要的信息，用于两个会话实体之间的媒体协商。</p>
<h4 id="2、sdp协议结构"><a href="#2、sdp协议结构" class="headerlink" title="2、sdp协议结构"></a>2、sdp协议结构</h4><h5 id="SDP的文本信息包括："><a href="#SDP的文本信息包括：" class="headerlink" title="SDP的文本信息包括："></a>SDP的文本信息包括：</h5><ul>
<li>会话信息  </li>
<li>网络信息  </li>
<li>媒体信息  </li>
<li>安全信息  </li>
<li>服务质量和分组信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                                                +---------------------+</span><br><span class="line">                                                |        v=           |</span><br><span class="line">                                                +---------------------+</span><br><span class="line">                +---------------------+         +---------------------+</span><br><span class="line">        ====    |   Session Metadata  |  =====  |        o=           |</span><br><span class="line">        |       +---------------------+         +----------------------</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |        t=           |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |        c=           |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |       +---------------------+</span><br><span class="line">        ====    | Network Description |   =====</span><br><span class="line">        |       +---------------------+</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |    a=candidate      |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |        m=           |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |        +---------------------+        +---------------------+</span><br><span class="line">        ====     | Stream Description  |  ===== |      a=rtpmap       |</span><br><span class="line">        |        +---------------------+        +----------------------</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=fmtp         |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=sendrecv..   |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">+---------------+</span><br><span class="line">|    SEMANTIC   |</span><br><span class="line">| COMPONENTS OF |</span><br><span class="line">|     SDP       |</span><br><span class="line">+---------------+</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=crypto       |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |         +---------------------+       +---------------------+</span><br><span class="line">        ====      |Security Descriptions|  =====|      a=ice-frag     |</span><br><span class="line">        |         +---------------------+       +----------------------</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=ice-pwd      |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |     a=fingerprint   |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=rtcp-fb      |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |         +---------------------+       +---------------------+</span><br><span class="line">        ====      |   Qos,Grouping      |       |                     |</span><br><span class="line">                  |   Descriptions      |  =====|       a=group       |</span><br><span class="line">                  +---------------------+       +----------------------</span><br><span class="line">                                                +---------------------+</span><br><span class="line">                                                |       a=rtcpmux     |</span><br><span class="line">                                                +---------------------+</span><br></pre></td></tr></table></figure>

<h5 id="sdp格式"><a href="#sdp格式" class="headerlink" title="sdp格式"></a>sdp格式</h5><p>SDP描述由许多文本行组成，文本行的格式为&lt;类型&gt;&#x3D;&lt;值&gt;，&lt;类型&gt;是一个字母，&lt;值&gt;是结构化的文本串，其格式依&lt;类型&gt;而定，每个SDP有一个会话级描述、多个媒体级描述。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;=&lt;value&gt;</span><br><span class="line"></span><br><span class="line">&lt;type&gt;: 区分大小写，代表特定的属性，例如v代表SDP版本。</span><br><span class="line">&lt;value&gt;：UTF8编码的文本，具体格式与类型有关。</span><br><span class="line">=两边不允许存在空格。</span><br><span class="line">=*表示该项是可选的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>会话的名称和目的 Session Description</p>
<blockquote>
<p>v &#x3D; （协议版本）<br>o &#x3D; （所有者&#x2F;创建者和会话标识符）<br>s &#x3D; （会话名称）<br>i &#x3D; * （会话信息）<br>u &#x3D; * （URI 描述）<br>e &#x3D; * （Email 地址）<br>p &#x3D; * （电话号码）<br>c &#x3D; * （连接信息 ― 如果包含在所有媒体中，则不需要该字段）<br>b &#x3D; * （带宽信息）  </p>
</blockquote>
<p>会话存活时间   Time Description</p>
<blockquote>
<p>t &#x3D; （会话活动时间）<br>r &#x3D; * （0或多次重复次数）  </p>
</blockquote>
<p>构成会话的媒体(会话中包括多个媒体)<br>SDP的媒体信息  Media Description<br>媒体格式<br>传输协议<br>传输IP和端口<br>媒体负载类型(VP8、VP9、H264、H265)  </p>
<blockquote>
<p>m &#x3D; （媒体名称和传输地址）<br>i &#x3D; * （媒体标题）<br>c &#x3D; * （连接信息 — 如果包含在会话层则该字段可选）<br>b &#x3D; * （带宽信息）<br>k &#x3D; * （加密密钥）<br>a &#x3D; * （0 个或多个会话属性行）  </p>
</blockquote>
<h4 id="3、sdp实例"><a href="#3、sdp实例" class="headerlink" title="3、sdp实例"></a>3、sdp实例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">                      【Session Metadata部分】</span><br><span class="line">v=0</span><br><span class="line">//sdp版本号，一直为0,rfc4566规定</span><br><span class="line"></span><br><span class="line">o=- 7017624586836067756 2 IN IP4 127.0.0.1</span><br><span class="line">//origion/owner  o=&lt;username&gt; &lt;session id&gt; &lt;version&gt; &lt;network type&gt; &lt;address type&gt; &lt;unicast-address&gt;</span><br><span class="line">//username如何没有使用-代替，7017624586836067756是整个会话的编号，2代表会话版本，如果在会话</span><br><span class="line">//过程中有改变编码之类的操作，重新生成sdp时,sess-id不变，sess-version加1</span><br><span class="line"></span><br><span class="line">s=-</span><br><span class="line">//会话名,必选，没有的话使用-代替</span><br><span class="line"></span><br><span class="line">t=0 0</span><br><span class="line">//两个值分别是会话的起始时间和结束时间，这里都是0代表没有限制</span><br><span class="line"></span><br><span class="line">a=group:BUNDLE audio video data</span><br><span class="line">//需要共用一个传输通道传输的媒体，如果没有这一行，音视频，数据就会分别单独用一个udp端口来发送</span><br><span class="line"></span><br><span class="line">a=msid-semantic: WMS h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C</span><br><span class="line">//WMS是WebRTC Media Stream简称，这一行定义了本客户端支持同时传输多个流，一个流可以包括多个track,</span><br><span class="line">//一般定义了这个，后面a=ssrc这一行就会有msid,mslabel等属性</span><br><span class="line"></span><br><span class="line">                          【Stream Description部分】</span><br><span class="line">        </span><br><span class="line">        【audio部分】</span><br><span class="line">        </span><br><span class="line">m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 126</span><br><span class="line">//m = &lt;media&gt;&lt;port&gt;&lt;transport&gt;&lt;fmt/payload type list&gt;</span><br><span class="line">//m=audio说明本会话包含音频，9代表音频使用端口9来传输，但是在webrtc中一现在一般不使用，如果设置为0，代表不</span><br><span class="line">//传输音频,UDP/TLS/RTP/SAVPF是表示用户来传输音频支持的协议，udp，tls,rtp代表使用udp来传输rtp包，并使用tls加密</span><br><span class="line">//SAVPF代表使用srtcp的反馈机制来控制通信过程,后台111 103 104 9 0 8 106 105 13 126表示本会话音频支持的编码，后台几行会有详细补充说明</span><br><span class="line"></span><br><span class="line">c=IN IP4 0.0.0.0</span><br><span class="line">//这一行表示你要用来接收或者发送音频使用的IP地址，webrtc使用ice传输，不使用这个地址</span><br><span class="line"></span><br><span class="line">a=rtcp:9 IN IP4 0.0.0.0</span><br><span class="line">//用来传输rtcp地地址和端口，webrtc中不使用</span><br><span class="line"></span><br><span class="line">a=ice-ufrag:khLS</span><br><span class="line">a=ice-pwd:cxLzteJaJBou3DspNaPsJhlQ</span><br><span class="line">//以上两行是ice协商过程中的安全验证信息</span><br><span class="line"></span><br><span class="line">a=fingerprint:sha-256 FA:14:42:3B:C7:97:1B:E8:AE:0C2:71:03:05:05:16:8F:B9:C7:98:E9:60:43:4B:5B:2C:28:EE:5C:8F3:17</span><br><span class="line">//以上这行是dtls协商过程中需要的认证信息</span><br><span class="line"></span><br><span class="line">a=setup:actpass</span><br><span class="line">//以上这行代表本客户端在dtls协商过程中，可以做客户端也可以做服务端，参考rfc4145 rfc4572</span><br><span class="line"></span><br><span class="line">a=mid:audio</span><br><span class="line">//在前面BUNDLE这一行中用到的媒体标识</span><br><span class="line"></span><br><span class="line">a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level</span><br><span class="line">//上一行指出我要在rtp头部中加入音量信息，参考 rfc6464</span><br><span class="line"></span><br><span class="line">a=sendrecv</span><br><span class="line">//上一行指出我是双向通信，另外几种类型是recvonly,sendonly,inactive</span><br><span class="line"></span><br><span class="line">a=rtcp-mux</span><br><span class="line">//上一行指出rtp,rtcp包使用同一个端口来传输</span><br><span class="line"></span><br><span class="line">//下面几行都是对m=audio这一行的媒体编码补充说明，指出了编码采用的编号，采样率，声道等</span><br><span class="line">a=rtpmap:111 opus/48000/2</span><br><span class="line">//可选 a=rtpmap:&lt;fmt/payload type&gt;&lt;encoding name&gt;/&lt;clock rate&gt;[/&lt;encodingparameters&gt;]</span><br><span class="line"></span><br><span class="line">a=rtcp-fb:111 transport-cc</span><br><span class="line">//以上这行说明opus编码支持使用rtcp来控制拥塞，参考https://tools.ietf.org/html/draft-holmer-rmcat-transport-wide-cc-extensions-01</span><br><span class="line"></span><br><span class="line">a=fmtp:111 minptime=10;useinbandfec=1</span><br><span class="line">//可选 a=fmtp:&lt;fmt/payload type&gt; parameters  对rtpmap进一步说明</span><br><span class="line">//对opus编码可选的补充说明,minptime代表最小打包时长是10ms，useinbandfec=1代表使用opus编码内置fec特性</span><br><span class="line"></span><br><span class="line">a=rtpmap:103 ISAC/16000</span><br><span class="line">a=rtpmap:104 ISAC/32000</span><br><span class="line">a=rtpmap:9 G722/8000</span><br><span class="line">a=rtpmap:0 PCMU/8000</span><br><span class="line">a=rtpmap:8 PCMA/8000</span><br><span class="line">a=rtpmap:106 CN/32000</span><br><span class="line">a=rtpmap:105 CN/16000</span><br><span class="line">a=rtpmap:13 CN/8000</span><br><span class="line">a=rtpmap:126 telephone-event/8000</span><br><span class="line">a=ssrc:18509423 cname:sTjtznXLCNH7nbRw</span><br><span class="line">//cname用来标识一个数据源，ssrc当发生冲突时可能会发生变化，但是cname不会发生变化，也会出现在rtcp包中SDEC中，</span><br><span class="line">//用于音视频同步</span><br><span class="line"></span><br><span class="line">a=ssrc:18509423 msid:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C 15598a91-caf9-4fff-a28f-3082310b2b7a</span><br><span class="line">//以上这一行定义了ssrc和WebRTC中的MediaStream,AudioTrack之间的关系，msid后面第一个属性是stream-d,第二个是track-id</span><br><span class="line"></span><br><span class="line">a=ssrc:18509423 mslabel:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C</span><br><span class="line">a=ssrc:18509423 label:15598a91-caf9-4fff-a28f-3082310b2b7a</span><br><span class="line"></span><br><span class="line">       【video部分】</span><br><span class="line">       </span><br><span class="line">m=video 9 UDP/TLS/RTP/SAVPF 100 101 107 116 117 96 97 99 98</span><br><span class="line">//参考上面m=audio,含义类似</span><br><span class="line"></span><br><span class="line">c=IN IP4 0.0.0.0</span><br><span class="line">a=rtcp:9 IN IP4 0.0.0.0</span><br><span class="line">a=ice-ufrag:khLS</span><br><span class="line">a=ice-pwd:cxLzteJaJBou3DspNaPsJhlQ</span><br><span class="line">a=fingerprint:sha-256 FA:14:42:3B:C7:97:1B:E8:AE:0C2:71:03:05:05:16:8F:B9:C7:98:E9:60:43:4B:5B:2C:28:EE:5C:8F3:17</span><br><span class="line">a=setup:actpass</span><br><span class="line">a=mid:video</span><br><span class="line">a=extmap:2 urn:ietf:params:rtp-hdrext:toffset</span><br><span class="line">a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time</span><br><span class="line">a=extmap:4 urn:3gpp:video-orientation</span><br><span class="line">a=extmap:5 http://www.ietf.org/id/draft-hol ... de-cc-extensions-01</span><br><span class="line">a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/playout-delay</span><br><span class="line">a=sendrecv</span><br><span class="line">a=rtcp-mux</span><br><span class="line">a=rtcp-rsize</span><br><span class="line">a=rtpmap:100 VP8/90000</span><br><span class="line">a=rtcp-fb:100 ccm fir</span><br><span class="line">//ccm是codec control using RTCP feedback message简称，意思是支持使用rtcp反馈机制来实现编码控制，fir是Full Intra Request</span><br><span class="line">//简称，意思是接收方通知发送方发送幅完全帧过来</span><br><span class="line">a=rtcp-fb:100 nack</span><br><span class="line">//支持丢包重传，参考rfc4585</span><br><span class="line"></span><br><span class="line">a=rtcp-fb:100 nack pli</span><br><span class="line">//支持关键帧丢包重传,参考rfc4585</span><br><span class="line"></span><br><span class="line">a=rtcp-fb:100 goog-remb</span><br><span class="line">//支持使用rtcp包来控制发送方的码流</span><br><span class="line"></span><br><span class="line">a=rtcp-fb:100 transport-cc</span><br><span class="line">//参考上面opus</span><br><span class="line">a=rtpmap:101 VP9/90000</span><br><span class="line">a=rtcp-fb:101 ccm fir</span><br><span class="line">a=rtcp-fb:101 nack</span><br><span class="line">a=rtcp-fb:101 nack pli</span><br><span class="line">a=rtcp-fb:101 goog-remb</span><br><span class="line">a=rtcp-fb:101 transport-cc</span><br><span class="line">a=rtpmap:107 H264/90000</span><br><span class="line">a=rtcp-fb:107 ccm fir</span><br><span class="line">a=rtcp-fb:107 nack</span><br><span class="line">a=rtcp-fb:107 nack pli</span><br><span class="line">a=rtcp-fb:107 goog-remb</span><br><span class="line">a=rtcp-fb:107 transport-cc</span><br><span class="line">a=fmtp:107 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f</span><br><span class="line"></span><br><span class="line">//h264编码可选的附加说明</span><br><span class="line">a=rtpmap:116 red/90000</span><br><span class="line">//fec冗余编码，一般如果sdp中有这一行的话，rtp头部负载类型就是116，否则就是各编码原生负责类型</span><br><span class="line"></span><br><span class="line">a=rtpmap:117 ulpfec/90000</span><br><span class="line">//支持ULP FEC，参考rfc5109</span><br><span class="line"></span><br><span class="line">a=rtpmap:96 rtx/90000</span><br><span class="line">a=fmtp:96 apt=100</span><br><span class="line">//以上两行是VP8编码的重传包rtp类型</span><br><span class="line"></span><br><span class="line">a=rtpmap:97 rtx/90000</span><br><span class="line">a=fmtp:97 apt=101</span><br><span class="line">a=rtpmap:99 rtx/90000</span><br><span class="line">a=fmtp:99 apt=107</span><br><span class="line">a=rtpmap:98 rtx/90000</span><br><span class="line">a=fmtp:98 apt=116</span><br><span class="line">a=ssrc-group:FID 3463951252 1461041037</span><br><span class="line">//在webrtc中，重传包和正常包ssrc是不同的，上一行中前一个是正常rtp包的ssrc,后一个是重传包的ssrc</span><br><span class="line"></span><br><span class="line">a=ssrc:3463951252 cname:sTjtznXLCNH7nbRw</span><br><span class="line">a=ssrc:3463951252 msid:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C ead4b4e9-b650-4ed5-86f8-6f5f5806346d</span><br><span class="line">a=ssrc:3463951252 mslabel:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C</span><br><span class="line">a=ssrc:3463951252 label:ead4b4e9-b650-4ed5-86f8-6f5f5806346d</span><br><span class="line">a=ssrc:1461041037 cname:sTjtznXLCNH7nbRw</span><br><span class="line">a=ssrc:1461041037 msid:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C ead4b4e9-b650-4ed5-86f8-6f5f5806346d</span><br><span class="line">a=ssrc:1461041037 mslabel:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C</span><br><span class="line">a=ssrc:1461041037 label:ead4b4e9-b650-4ed5-86f8-6f5f5806346d</span><br><span class="line">m=application 9 DTLS/SCTP 5000</span><br><span class="line">c=IN IP4 0.0.0.0</span><br><span class="line">a=ice-ufrag:khLS</span><br><span class="line">a=ice-pwd:cxLzteJaJBou3DspNaPsJhlQ</span><br><span class="line">a=fingerprint:sha-256 FA:14:42:3B:C7:97:1B:E8:AE:0C2:71:03:05:05:16:8F:B9:C7:98:E9:60:43:4B:5B:2C:28:EE:5C:8F3:17</span><br><span class="line">a=setup:actpass</span><br><span class="line">a=mid:data</span><br><span class="line">a=sctpmap:5000 webrtc-datachannel 1024</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaomucgwlmx/article/details/103225720">WebRTC核心之SDP详解、媒体协商</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/94d6defc8e27">WebRTC – SDP格式解析</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020794391">WebRTC会话描述协议（SDP）详解</a></p>
<html>
    <table style="margin-left:auto; margin-right: auto;">
        <tr>
            <td>
             <img src="https://i.loli.net/2021/02/03/SXE7MICDbUh9Q3J.jpg" width = "110" height = "110"/>
            </td>
            <td>
<span>本文作者</span>：<strong><span style="font-size: 14px;"><a href="https://github.com/zhuyongchn" target="_blank">zhuyong</a></span></strong> <br>
<span>原文链接</span>：<strong><span style="font-size: 14px;"><a href="https://zhuyongchn.github.io" target="_blank">https://zhuyongchn.github.io</a></span></strong> <br>
<span class="essaySuffix-right-title">关于博主</span>：欢迎关注左侧公众号，获取更多干货。<br>
<span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" alt="BY-NC-SA" title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！<br>
            </td>
        </tr>
    </table>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/08/webrtc%20sdp(%E4%BC%9A%E8%AF%9D%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)%E8%AF%A6%E8%A7%A3/" data-id="clgrezjww0002skvte3n1e8nv" data-title="sdp(会话传输协议)详解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-valgrind和Kcachegrind性能分析工具详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/02/valgrind%E5%92%8CKcachegrind%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-02-02T10:57:15.000Z" itemprop="datePublished">2021-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/02/valgrind%E5%92%8CKcachegrind%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/">valgrind和Kcachegrind性能分析工具详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="一、valgrind介绍"><a href="#一、valgrind介绍" class="headerlink" title="一、valgrind介绍"></a>一、valgrind介绍</h4><p><code>valgrind</code>是运行在<code>Linux</code>上的一套基于仿真技术的程序调试和分析工具，用于构建动态分析工具的装备性框架。它包括一个工具集，每个工具执行某种类型的调试、分析或类似的任务，以帮助完善你的程序。<code>Valgrind</code>的架构是模块化的，所以可以容易的创建新的工具而又不会扰乱现有的结构。</p>
<p><code>valgrind</code>主要包含以下工具：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、memcheck：检查程序中的内存问题，如泄漏、越界、非法指针等。</span><br><span class="line"></span><br><span class="line">2、callgrind：检测程序代码的运行时间和调用过程，以及分析程序性能。</span><br><span class="line"></span><br><span class="line">3、cachegrind：分析CPU的cache命中率、丢失率，用于进行代码优化。</span><br><span class="line"></span><br><span class="line">4、helgrind：用于检查多线程程序的竞态条件。</span><br><span class="line"></span><br><span class="line">5、massif：堆栈分析器，指示程序中使用了多少堆内存等信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，也有一些大多数用户不会用到的小工具： <code>Lackey</code>是一个示例工具，用于演示一些装备的基础性内容；<code>Nulgrind</code>是一个最小化的<code>Valgrind</code>工具，不做分析或者操作，仅用于测试目的。</p>
<h4 id="二、valgrind安装及使用"><a href="#二、valgrind安装及使用" class="headerlink" title="二、valgrind安装及使用"></a>二、valgrind安装及使用</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>建议从<a target="_blank" rel="noopener" href="https://note.youdao.com/">valgrind官网</a>下载安装，目前官网的最新包是<code>3.16.1</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir valgrind-inst</span><br><span class="line">$ cd valgrind-inst/</span><br><span class="line">$ wget https://sourceware.org/pub/valgrind/valgrind-3.16.1.tar.bz2</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">valgrind-3.16.1.tar.bz2</span><br></pre></td></tr></table></figure>

<p>解压后进行安装，可以指定安装目录，这样的话记得设置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvf valgrind-3.16.1.tar.bz2</span><br><span class="line">$ cd valgrind-3.16.1</span><br><span class="line">$ ./configure --prefix=/usr/local/valgrind</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<p>查看是否安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --version</span><br><span class="line">valgrind-3.16.1</span><br></pre></td></tr></table></figure>

<h5 id="工具集的使用"><a href="#工具集的使用" class="headerlink" title="工具集的使用"></a>工具集的使用</h5><p>基本使用格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usage: valgrind [options] prog-and-args</span><br></pre></td></tr></table></figure>

<p>其支持众多选项，我们可以通过<code>valgrind --help</code>来进行查看。</p>
<p>这里我们只介绍几个较为常用的选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--tool: 是最常用的选项，用于选择使用valgrind工具集中的哪一个工具。默认值为memcheck。</span><br><span class="line"></span><br><span class="line">--version: 用于打印valgrind的版本号</span><br><span class="line"></span><br><span class="line">-q/--quiet: 安静的运行，只打印错误消息；</span><br><span class="line"></span><br><span class="line">-v/--verbose: 打印更详细的信息；</span><br><span class="line"></span><br><span class="line">--trace-children: 是否跟踪子进程，默认值为no;</span><br><span class="line"></span><br><span class="line">--track-fds: 是否追踪打开的文件描述符，默认为no</span><br><span class="line"></span><br><span class="line">--time-stamp=no|yes: 是否在打印出的每条消息之前加上时间戳信息。默认值为no</span><br><span class="line"></span><br><span class="line">--log-file=&lt;file&gt;: 指定将消息打印到某个文件</span><br><span class="line"></span><br><span class="line">--default-suppressions: 加载默认的抑制参数。</span><br><span class="line"></span><br><span class="line">--alignment: 指定malloc分配内存时的最小对齐字节数；</span><br><span class="line"></span><br><span class="line">如下的一些选项用于Memcheck工具：</span><br><span class="line"></span><br><span class="line">--leak-check=no|summary|full: 在退出时是否查找内存泄露。默认值为summary</span><br><span class="line"></span><br><span class="line">--show-leak-kinds=kind1,kind2,..: 显示哪一种类型的内存泄露。默认显示definite和possible这两种；</span><br></pre></td></tr></table></figure>

<h4 id="三、-Valgrind-工具详解"><a href="#三、-Valgrind-工具详解" class="headerlink" title="三、 Valgrind 工具详解"></a>三、 Valgrind 工具详解</h4><h5 id="1）-memcheck"><a href="#1）-memcheck" class="headerlink" title="1） memcheck"></a>1） memcheck</h5><p>最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到，一切对<code>malloc</code>、<code>free</code>、<code>new</code>、<code>delete</code>的调用都会被捕获。所以，它能检测以下问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、使用未初始化的内存。如果在定义一个变量时没有赋初始值，后边即使赋值了，使用这个变量的时候Memcheck也会报&quot;uninitialised value&quot;错误。使用中会发现，valgrind提示很多这个错误，由于关注的是内存泄漏问题，所以可以用--undef-value-errors=选项把这个错误提示屏蔽掉，具体可以看后面的选项解释。</span><br><span class="line"></span><br><span class="line">2、读/写释放后的内存块；</span><br><span class="line"></span><br><span class="line">3、内存读写越界（数组访问越界／访问已经释放的内存),读/写超出malloc分配的内存块；</span><br><span class="line"></span><br><span class="line">4、读/写不适当的栈中内存块；</span><br><span class="line"></span><br><span class="line">5、内存泄漏，指向一块内存的指针永远丢失；</span><br><span class="line"></span><br><span class="line">6、不正确的malloc/free或new/delete匹配（重复释放／使用不匹配的分配和释放函数）；</span><br><span class="line"></span><br><span class="line">7、内存覆盖，memcpy()相关函数中的dst和src指针重叠。</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p><strong>用法：</strong></p>
<p>将程序编译生成可执行文件后执行：<code>valgrind –leak-check=full ./程序名</code></p>
<p>注意：下面讨论的所有测试代码在编译时最好都加上<code>-g</code>选项（用来在<code>memcheck</code>的输出中生成行号）进行编译。</p>
<p><strong>测试程序验证：</strong></p>
<p>编写测试程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void func() &#123;</span><br><span class="line">    char *p = new char[10];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译后，用<code>valgrind</code>检测程序。<br>如果设置了<code>--leak-check=full</code>，<code>Memcheck</code>会给出详细的每个块是在哪里分配，并且给出分配时函数调用堆栈（编译的时候使用<code>-g</code>选项和去掉<code>-o</code>优化选项，就可以得到更详细的函数信息，可以精确到代码的某一行）。可以通过<code>--show-leak-kinds</code>选项来选择要详细报告哪几种类型的错误。<code>Memcheck</code>会把函数调用堆栈相同或相似的内存块信息，放到同一个条目来显示，可以通过<code>--leak-resolution</code>来控制这个”相似”判断的力度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -g -o test leak.cpp</span><br><span class="line">$ valgrind --tool=memcheck --leak-check=full ./test</span><br></pre></td></tr></table></figure>

<p><strong>检测结果如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">==6018== Memcheck, a memory error detector</span><br><span class="line">==6018== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==6018== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==6018== Command: ./test</span><br><span class="line">==6018== </span><br><span class="line">==6018== </span><br><span class="line">==6018== HEAP SUMMARY:</span><br><span class="line">==6018==     in use at exit: 10 bytes in 1 blocks</span><br><span class="line">==6018==   total heap usage: 1 allocs, 0 frees, 10 bytes allocated</span><br><span class="line">==6018== </span><br><span class="line">==6018== 10 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">==6018==    at 0x4C2AC58: operator new[](unsigned long) (vg_replace_malloc.c:431)</span><br><span class="line">==6018==    by 0x40062E: func() (leak.cpp:4)</span><br><span class="line">==6018==    by 0x40063D: main (leak.cpp:8)</span><br><span class="line">==6018== </span><br><span class="line">==6018== LEAK SUMMARY:</span><br><span class="line">==6018==    definitely lost: 10 bytes in 1 blocks</span><br><span class="line">==6018==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==6018==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==6018==    still reachable: 0 bytes in 0 blocks</span><br><span class="line">==6018==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==6018== </span><br><span class="line">==6018== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==6018== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<p><strong>结果说明：</strong></p>
<p>先看看输出信息中的<code>HEAP SUMMARY</code>，它表示程序在堆上分配内存的情况，其中的<code>1 allocs</code><br>表示程序分配了 <code>1</code> 次内存，<code>0 frees</code>表示程序释放了 <code>0</code> 次内存，<code>10 bytes allocated</code>表示分配了 <code>10</code> 个字节的内存。<br>另外，<code>Valgrind</code> 也会报告程序是在哪个位置发生内存泄漏。</p>
<p>上面<code>LEAK SUMMARY</code>会打印5种不同的类型，这里我们简单介绍一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">definitely lost: 明确丢失的内存。程序中存在内存泄露，应尽快修复。当程序结束时如果一块动态分配的内存没有被释放并且通过程序内的指针变量均无法访问这块内存则会报这个错误；</span><br><span class="line"></span><br><span class="line">indirectly lost: 间接丢失。当使用了含有指针成员的类或结构体时可能会报这个错误。这类错误无需直接修复，它们总是与definitely lost一起出现，只要修复definitely lost即可。</span><br><span class="line"></span><br><span class="line">possibly lost: 可能丢失。大多数情况下应视为与definitely lost一样需要尽快修复，除非你的程序让一个指针指向一块动态分配的内存（但不是这块内存的起始地址），然后通过运算得到这块内存的起始地址，再释放它。当程序结束时如果一块动态分配的内存没有被释放并且通过程序内的指针变量均无法访问这块内存的起始地址，但可以访问其中的某一部分数据，则会报这个错误。</span><br><span class="line"></span><br><span class="line">stil reachable: 可以访问，未丢失但也未释放。如果程序是正常结束的，那么它可能不会造成程序崩溃，但长时间运行有可能耗尽系统资源。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>其他几种情况，写一个综合的测试程序进行验证。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// mixed.cpp</span><br><span class="line"></span><br><span class="line">void func() &#123;</span><br><span class="line">    char *ptr = new char[10];</span><br><span class="line">    ptr[10] = &#x27;a&#x27;;   // 内存越界</span><br><span class="line"></span><br><span class="line">    memcpy(ptr + 1, ptr, 5);   // 踩内存</span><br><span class="line"></span><br><span class="line">    delete []ptr;</span><br><span class="line">    delete []ptr; // 重复释放</span><br><span class="line"></span><br><span class="line">    char *p;</span><br><span class="line">    *p = 1;   // 非法指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，用<code>valgrind</code>检测程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -g -o test mixed.cpp</span><br><span class="line">$ valgrind --tool=memcheck --leak-check=full ./test</span><br></pre></td></tr></table></figure>

<p><strong>检测结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">==22786== Memcheck, a memory error detector</span><br><span class="line">==22786== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==22786== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==22786== Command: ./test</span><br><span class="line">==22786== </span><br><span class="line">==22786== Invalid write of size 1      // 内存越界</span><br><span class="line">==22786==    at 0x4007FB: func() (mixed.cpp:6)</span><br><span class="line">==22786==    by 0x400851: main (mixed.cpp:18)</span><br><span class="line">==22786==  Address 0x5a2404a is 0 bytes after a block of size 10 alloc&#x27;d</span><br><span class="line">==22786==    at 0x4C2AC58: operator new[](unsigned long) (vg_replace_malloc.c:431)</span><br><span class="line">==22786==    by 0x4007EE: func() (mixed.cpp:5)</span><br><span class="line">==22786==    by 0x400851: main (mixed.cpp:18)</span><br><span class="line">==22786== </span><br><span class="line">==22786== Source and destination overlap in memcpy(0x5a24041, 0x5a24040, 5)  // 踩内存</span><br><span class="line">==22786==    at 0x4C2E83D: memcpy@@GLIBC_2.14 (vg_replace_strmem.c:1033)</span><br><span class="line">==22786==    by 0x400819: func() (mixed.cpp:8)</span><br><span class="line">==22786==    by 0x400851: main (mixed.cpp:18)</span><br><span class="line">==22786== </span><br><span class="line">==22786== Invalid free() / delete / delete[] / realloc()    // 重复释放</span><br><span class="line">==22786==    at 0x4C2BBAF: operator delete[](void*) (vg_replace_malloc.c:649)</span><br><span class="line">==22786==    by 0x40083F: func() (mixed.cpp:11)</span><br><span class="line">==22786==    by 0x400851: main (mixed.cpp:18)</span><br><span class="line">==22786==  Address 0x5a24040 is 0 bytes inside a block of size 10 free&#x27;d</span><br><span class="line">==22786==    at 0x4C2BBAF: operator delete[](void*) (vg_replace_malloc.c:649)</span><br><span class="line">==22786==    by 0x40082C: func() (mixed.cpp:10)</span><br><span class="line">==22786==    by 0x400851: main (mixed.cpp:18)</span><br><span class="line">==22786==  Block was alloc&#x27;d at</span><br><span class="line">==22786==    at 0x4C2AC58: operator new[](unsigned long) (vg_replace_malloc.c:431)</span><br><span class="line">==22786==    by 0x4007EE: func() (mixed.cpp:5)</span><br><span class="line">==22786==    by 0x400851: main (mixed.cpp:18)</span><br><span class="line">==22786== </span><br><span class="line">==22786== Use of uninitialised value of size 8    // 非法指针</span><br><span class="line">==22786==    at 0x400844: func() (mixed.cpp:14)</span><br><span class="line">==22786==    by 0x400851: main (mixed.cpp:18)</span><br><span class="line">==22786== </span><br><span class="line">==22786== </span><br><span class="line">==22786== Process terminating with default action of signal 11 (SIGSEGV): dumping core</span><br><span class="line">==22786==  Bad permissions for mapped region at address 0x4008B0</span><br><span class="line">==22786==    at 0x400844: func() (mixed.cpp:14)</span><br><span class="line">==22786==    by 0x400851: main (mixed.cpp:18)</span><br><span class="line">==22786== </span><br><span class="line">==22786== HEAP SUMMARY:</span><br><span class="line">==22786==     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">==22786==   total heap usage: 1 allocs, 2 frees, 10 bytes allocated</span><br><span class="line">==22786== </span><br><span class="line">==22786== All heap blocks were freed -- no leaks are possible</span><br><span class="line">==22786== </span><br><span class="line">==22786== Use --track-origins=yes to see where uninitialised values come from  </span><br><span class="line">==22786== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==22786== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<p>可见<code>valgrind</code>将上述几种情况都检测出来了。</p>
<h5 id="2）-Callgrind"><a href="#2）-Callgrind" class="headerlink" title="2） Callgrind"></a>2） Callgrind</h5><p>和<code>gprof</code>类似的分析工具，但它对程序的运行观察更为入微，能给我们提供更多的信息。和<code>gprof</code>不同的是，它不需要在编译源代码时附加特殊选项，但还是推荐加上调试选项。<code>Callgrind</code>收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行<code>cache</code>模拟。在运行结束时，它会把分析数据写入一个文件。<code>callgrind_annotate</code>可以把这个文件的内容转化成可读的形式。</p>
<p><strong>测试程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">void func() &#123;</span><br><span class="line">    for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    func();</span><br><span class="line">    printf(&quot;process is over!\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，用<code>valgrind</code>检测程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -g -o test callgrind.cpp</span><br><span class="line">$ valgrind --tool=callgrind ./test</span><br><span class="line">$ ls</span><br><span class="line">callgrind.cpp  callgrind.out.3490  test</span><br></pre></td></tr></table></figure>

<p><code>callgrind.out.3490</code>就是<code>callgrind</code>生成的文件。</p>
<p>这里介绍一个图形化性能分析工具<code>Kcachegrind</code></p>
<p><a target="_blank" rel="noopener" href="http://kcachegrind.sourceforge.net/html/Home.html">Kcachegrind官网地址</a></p>
<p>下载安装后可以用来分析<code>callgrind</code>生成的文件。</p>
<p>用<code>Kcachegrind</code>打开<code>callgrind.out.3490</code>这个文件，如下图：</p>
<p><img src="https://i.loli.net/2021/02/03/tRIXdOg39sapN16.png" alt="callgrind"></p>
<p>通过图形化，我们可以很直观的知道哪段程序执行慢，并且了解相关调用关系。</p>
<h5 id="3）-Cachegrind"><a href="#3）-Cachegrind" class="headerlink" title="3） Cachegrind"></a>3） Cachegrind</h5><p><code>Cache</code>分析器，它模拟CPU中的<code>一级缓</code>存和<code>二级缓存</code>，能够精确地指出程序中<code>cache的丢失和命中</code>。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。</p>
<p>它的使用方法也是：<code>valgrind –tool=cachegrind ./程序名</code></p>
<h5 id="4）-Helgrind"><a href="#4）-Helgrind" class="headerlink" title="4） Helgrind"></a>4） Helgrind</h5><p>它主要用来检查多线程程序中出现的竞争问题。<code>Helgrind</code>寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发觉的错误。<code>Helgrind</code>实现了名为<code>Eraser</code>的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，<code>Helgrind</code>仍然处于实验状态。</p>
<p><strong>测试代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">#define NUM 10</span><br><span class="line">int counter = 0;</span><br><span class="line"></span><br><span class="line">void *threadfunc(void*) &#123;</span><br><span class="line">    for (int i = 0; i &lt; NUM; i++) &#123;</span><br><span class="line">        counter += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    pthread_t tid1, tid2;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid1, NULL, &amp;threadfunc, NULL);</span><br><span class="line">    pthread_create(&amp;tid2, NULL, &amp;threadfunc, NULL);</span><br><span class="line"></span><br><span class="line">    // wait for thread to terminate</span><br><span class="line">    pthread_join(tid1, NULL);</span><br><span class="line">    pthread_join(tid2, NULL);</span><br><span class="line"></span><br><span class="line">    printf(&quot;counter = %d\n&quot;, counter);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，用<code>valgrind</code>检测程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -g -o test helgrind.cpp -lpthread</span><br><span class="line">$ valgrind --tool=helgrind ./test</span><br></pre></td></tr></table></figure>

<p><strong>检测结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">==27722== Helgrind, a thread error detector</span><br><span class="line">==27722== Copyright (C) 2007-2017, and GNU GPL&#x27;d, by OpenWorks LLP et al.</span><br><span class="line">==27722== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==27722== Command: ./test</span><br><span class="line">==27722== </span><br><span class="line">==27722== ---Thread-Announcement------------------------------------------</span><br><span class="line">==27722== </span><br><span class="line">==27722== Thread #3 was created</span><br><span class="line">==27722==    at 0x597589E: clone (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==27722==    by 0x4E43059: do_clone.constprop.4 (in /usr/lib64/libpthread-2.17.so)</span><br><span class="line">==27722==    by 0x4E44569: pthread_create@@GLIBC_2.2.5 (in /usr/lib64/libpthread-2.17.so)</span><br><span class="line">==27722==    by 0x4C30CFA: pthread_create_WRK (hg_intercepts.c:425)</span><br><span class="line">==27722==    by 0x4C31DD8: pthread_create@* (hg_intercepts.c:458)</span><br><span class="line">==27722==    by 0x400728: main (helgrind.cpp:17)</span><br><span class="line">==27722== </span><br><span class="line">==27722== ---Thread-Announcement------------------------------------------</span><br><span class="line">==27722== </span><br><span class="line">==27722== Thread #2 was created</span><br><span class="line">==27722==    at 0x597589E: clone (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==27722==    by 0x4E43059: do_clone.constprop.4 (in /usr/lib64/libpthread-2.17.so)</span><br><span class="line">==27722==    by 0x4E44569: pthread_create@@GLIBC_2.2.5 (in /usr/lib64/libpthread-2.17.so)</span><br><span class="line">==27722==    by 0x4C30CFA: pthread_create_WRK (hg_intercepts.c:425)</span><br><span class="line">==27722==    by 0x4C31DD8: pthread_create@* (hg_intercepts.c:458)</span><br><span class="line">==27722==    by 0x40070D: main (helgrind.cpp:16)</span><br><span class="line">==27722== </span><br><span class="line">==27722== ----------------------------------------------------------------</span><br><span class="line">==27722== </span><br><span class="line">==27722== Possible data race during read of size 4 at 0x601048 by thread #3</span><br><span class="line">==27722== Locks held: none</span><br><span class="line">==27722==    at 0x4006CE: threadfunc(void*) (helgrind.cpp:9)</span><br><span class="line">==27722==    by 0x4C30EEE: mythread_wrapper (hg_intercepts.c:387)</span><br><span class="line">==27722==    by 0x4E43EA4: start_thread (in /usr/lib64/libpthread-2.17.so)</span><br><span class="line">==27722==    by 0x59758DC: clone (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==27722== </span><br><span class="line">==27722== This conflicts with a previous write of size 4 by thread #2</span><br><span class="line">==27722== Locks held: none</span><br><span class="line">==27722==    at 0x4006D9: threadfunc(void*) (helgrind.cpp:9)</span><br><span class="line">==27722==    by 0x4C30EEE: mythread_wrapper (hg_intercepts.c:387)</span><br><span class="line">==27722==    by 0x4E43EA4: start_thread (in /usr/lib64/libpthread-2.17.so)</span><br><span class="line">==27722==    by 0x59758DC: clone (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==27722==  Address 0x601048 is 0 bytes inside data symbol &quot;counter&quot;</span><br><span class="line">==27722== </span><br><span class="line">==27722== ----------------------------------------------------------------</span><br><span class="line">==27722== </span><br><span class="line">==27722== Possible data race during write of size 4 at 0x601048 by thread #3</span><br><span class="line">==27722== Locks held: none</span><br><span class="line">==27722==    at 0x4006D9: threadfunc(void*) (helgrind.cpp:9)</span><br><span class="line">==27722==    by 0x4C30EEE: mythread_wrapper (hg_intercepts.c:387)</span><br><span class="line">==27722==    by 0x4E43EA4: start_thread (in /usr/lib64/libpthread-2.17.so)</span><br><span class="line">==27722==    by 0x59758DC: clone (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==27722== </span><br><span class="line">==27722== This conflicts with a previous write of size 4 by thread #2</span><br><span class="line">==27722== Locks held: none</span><br><span class="line">==27722==    at 0x4006D9: threadfunc(void*) (helgrind.cpp:9)</span><br><span class="line">==27722==    by 0x4C30EEE: mythread_wrapper (hg_intercepts.c:387)</span><br><span class="line">==27722==    by 0x4E43EA4: start_thread (in /usr/lib64/libpthread-2.17.so)</span><br><span class="line">==27722==    by 0x59758DC: clone (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==27722==  Address 0x601048 is 0 bytes inside data symbol &quot;counter&quot;</span><br><span class="line">==27722== </span><br><span class="line">counter = 90</span><br><span class="line">==27722== </span><br><span class="line">==27722== Use --history-level=approx or =none to gain increased speed, at</span><br><span class="line">==27722== the cost of reduced accuracy of conflicting-access information</span><br><span class="line">==27722== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==27722== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<p>从上述结果知道，<code>valgrind</code>分析出了竞态的情况。</p>
<p>5） Massif</p>
<p>堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。<code>Massif</code>能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。</p>
<p><code>Massif</code>对内存的分配和释放做<code>profile</code>。程序开发者通过它可以深入了解程序的内存使用行为，从而对内存使用进行优化。这个功能对<code>C++</code>尤其有用，因为<code>C++</code>有很多隐藏的内存分配和释放。</p>
<p>此外，<code>lackey</code> 和 <code>nulgrind</code> 也会提供。<code>Lackey</code> 是小型工具，很少用到；<code>Nulgrind</code> 只是为开发者展示如何创建一个工具。这里就不做介绍了。</p>
<p><strong>参考列表</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://ivanzz1001.github.io/records/post/cplusplus/2018/11/14/cpluscplus-valgrind_usage#27-memcheck%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B">valgrind的使用</a></p>
<p><a target="_blank" rel="noopener" href="https://learnku.com/articles/46663">Linux 下利用 valgrind工具进行内存泄露检测和性能分析</a></p>
<p><a target="_blank" rel="noopener" href="http://easy.ac.cn/blog/001444131836556a2f56413f49f4f0992fa1375df8b06dc000">valgrind详解与使用实例</a></p>
<p><a target="_blank" rel="noopener" href="http://senlinzhan.github.io/2017/12/31/valgrind/">使用 Valgrind 检测 C++内存泄漏</a></p>
<p><a target="_blank" rel="noopener" href="https://soaringleefighting.github.io/2020/07/24/%E3%80%90Tools%E7%B3%BB%E5%88%97%E3%80%91%E5%88%A9%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7valgrind+KCachegrind%E5%88%86%E6%9E%90/">利用性能分析工具valgrind+KCachegrind分析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qcloud1001/p/8584077.html">Linux性能分析工具与图形化方法</a></p>
<html>
    <table style="margin-left:auto; margin-right: auto;">
        <tr>
            <td>
             <img src="https://i.loli.net/2021/02/03/SXE7MICDbUh9Q3J.jpg" width = "110" height = "110"/>
            </td>
            <td>
<span>本文作者</span>：<strong><span style="font-size: 14px;"><a href="https://github.com/zhuyongchn" target="_blank">zhuyong</a></span></strong> <br>
<span>原文链接</span>：<strong><span style="font-size: 14px;"><a href="https://zhuyongchn.github.io" target="_blank">https://zhuyongchn.github.io</a></span></strong> <br>
<span class="essaySuffix-right-title">关于博主</span>：欢迎关注左侧公众号，获取更多干货。<br>
<span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" alt="BY-NC-SA" title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！<br>
            </td>
        </tr>
    </table>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/02/valgrind%E5%92%8CKcachegrind%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/" data-id="clgrezjwu0001skvt25rgbtlg" data-title="valgrind和Kcachegrind性能分析工具详解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">我的第一篇博客文章</a>
          </li>
        
          <li>
            <a href="/2023/04/22/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/03/16/GDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">GDB调试命令详解</a>
          </li>
        
          <li>
            <a href="/2021/02/08/webrtc%20sdp(%E4%BC%9A%E8%AF%9D%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)%E8%AF%A6%E8%A7%A3/">sdp(会话传输协议)详解</a>
          </li>
        
          <li>
            <a href="/2021/02/02/valgrind%E5%92%8CKcachegrind%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/">valgrind和Kcachegrind性能分析工具详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>