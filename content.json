{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"GDB调试命令详解","slug":"GDB调试命令详解","date":"2021-03-16T08:09:41.000Z","updated":"2021-03-16T08:20:45.507Z","comments":true,"path":"2021/03/16/GDB调试命令详解/","link":"","permalink":"http://example.com/2021/03/16/GDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"GDB是什么调试程序程序中出现的语法错误可以借助编译器解决；但逻辑错误则只能靠自己解决。实际场景中解决逻辑错误最高效的方法，就是借助调试工具对程序进行调试。 所谓调试（Debug），就是让代码一步一步慢慢执行，跟踪程序的运行过程。比如，可以让程序停在某个地方，查看当前所有变量的值，或者内存中的数据；也可以让程序一次只执行一条或者几条语句，看看程序到底执行了哪些代码。 也就是说，通过调试程序，我们可以监控程序执行的每一个细节，包括变量的值、函数的调用过程、内存中数据、线程的调度等，从而发现隐藏的错误或者低效的代码。 GDB的作用GDB 全称“GNU symbolic debugger”，从名称上不难看出，它诞生于 GNU 计划（同时诞生的还有 GCC、Emacs 等），是 Linux 下常用的程序调试器。发展至今，GDB 已经迭代了诸多个版本，当下的 GDB 支持调试多种编程语言编写的程序，包括 C、C++、Go、Objective-C、OpenCL、Ada等。实际场景中，GDB 更常用来调试 C 和 C++ 程序。 总的来说，借助 GDB调试器可以实现以下几个功能： 程序启动时，可以按照我们自定义的要求运行程序，例如设置参数和环境变量； 可使被调试程序在指定代码处暂停运行，并查看当前程序的运行状态（例如当前变量的值，函数的执行结果等），即支持断点调试； 程序执行过程中，可以改变某个变量的值，还可以改变代码的执行顺序，从而尝试修改程序中出现的逻辑错误。 GDB安装1、通过包管理器进行安装 1$ yum -y install gdb 2、源码安装GDB 在gdb源码包上面下载相应的版本进行安装即可。 3、查看GDB版本 输入gdb -v,即可查看当前安装的gdb的版本。 12345678910$ gdb -vGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;. 如果显示出gdb的版本，也说明了安装成功。 GDB的用法常用调试命令GDB 的主要功能就是监控程序的执行流程。这也就意味着，只有当源程序文件编译为可执行文件并执行时，并且该文件中必须包含必要的调试信息（比如各行代码所在的行号、包含程序中所有变量名称的列表（又称为符号表）等），GDB 才会派上用场。 所以在编译时需要使用 gcc/g++ -g 选项编译源文件，才可生成满足 GDB 要求的可执行文件 调试命令 (缩写) 作用 (gdb) break (b) 在源代码指定的某一行设置断点，其中xxx用于指定具体打断点位置 (gdb) run (r) 执行被调试的程序，其会自动在第一个断点处暂停执行。 (gdb) continue (c) 当程序在某一断点处停止后，用该指令可以继续执行，直至遇到断点或者程序结束。 (gdb) next (n) 令程序一行代码一行代码的执行。 (gdb) step（s） 如果有调用函数，进入调用的函数内部；否则，和 next 命令的功能一样。 (gdb) until (u) (gdb) until (u) location 当你厌倦了在一个循环体内单步跟踪时，单纯使用 until 命令，可以运行程序直到退出循环体。until n 命令中，n 为某一行代码的行号，该命令会使程序运行至第 n 行代码处停止。 (gdb) print (p) 打印指定变量的值，其中 xxx 指的就是某一变量名。 (gdb) list (l) 显示源程序代码的内容，包括各行代码所在的行号。 (gdb) finish（fi） 结束当前正在执行的函数，并在跳出函数后暂停程序的执行。 (gdb) return（return） 结束当前调用函数并返回指定值，到上一层函数调用处停止程序执行。 (gdb) jump（j) 使程序从当前要执行的代码处，直接跳转到指定位置处继续执行后续的代码。 (gdb) quit (q) 终止调试。 示例： 1234567891011121314151617$ lsmain.cpp$ g++ -g -o test main.cpp$ lsmain.cpp test$ gdb test &lt;-- 启动gdb进行调试GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/zhuyong/project/linux/blog/gdb/test...done.(gdb) gdb启动时会默认打印一堆免责条款，通过添加 --silent（或者 -q、--quiet）选项，可将这部分信息屏蔽掉。 下面先用个例子运行下上述调试命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$ gdb test -q &lt;-- 启动gdb进行调试Reading symbols from /home/zhudi/project/linux/blog/gdb/test...done.(gdb) l &lt;-- 显示带行号的源代码1 #include &lt;iostream&gt;2 using namespace std;34 int main() &#123;5 int sum = 0;6 int n = 1;7 while (n &lt;= 100) &#123;8 sum += n;9 n++;10 &#125;(gdb) &lt;-- 默认情况下，l 选项只显示 10 行源代码，如果查看后续代码，按 Enter 回车键即可11 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;1213 return 0;14 &#125;15(gdb) b 7 &lt;-- 在第7行源代码处打断点Breakpoint 1 at 0x4008d3: file main.cpp, line 7.(gdb) r &lt;-- 运行程序，遇到断点停止Starting program: /home/zhudi/project/linux/blog/gdb/testBreakpoint 1, main () at main.cpp:77 while (n &lt;= 100) &#123;Missing separate debuginfos, use: debuginfo-install glibc-2.17-307.el7.1.x86_64 libgcc-4.8.5-39.el7.x86_64 libstdc++-4.8.5-39.el7.x86_64(gdb) print n &lt;-- 查看代码中变量 n 的值$1 = 1 &lt;-- 当前 n 的值为 1，$1 表示该变量 表示该变量所在存储区的名称(gdb) b 13Breakpoint 2 at 0x40090e: file main.cpp, line 13.(gdb) n &lt;-- 单步执行程序8 sum += n;(gdb) n &lt;-- 单步执行程序9 n++;(gdb) c &lt;-- 继续执行程序Continuing.sum = 5050Breakpoint 2, main () at main.cpp:1313 return 0;(gdb) print sum &lt;-- 查看 sum 的值 $2 = 5050 &lt;-- 当前 sum 的值为 5050(gdb) q &lt;-- 退出调试A debugging session is active. Inferior 1 [process 8449] will be killed.Quit anyway? (y or n) y &lt;-- 确认是否退出调试，y 为退出，n 为不退出 接下来分别介绍下各个命令的用法 GDB 断点调试启动程序根据不同场景的需要，GDB 调试器提供了多种方式来启动目标程序，其中最常用的就是 run 指令，其次为 start 指令。也就是说，run 和 start 指令都可以用来在 GDB 调试器中启动程序，它们之间的区别是： 默认情况下，run 指令会一直执行程序，直到执行结束。如果程序中手动设置有断点，则 run 指令会执行程序至第一个断点处； start 指令会执行程序至main()主函数的起始位置，即在main()函数的第一行语句处停止执行（该行代码尚未执行）。 break命令break 命令（可以用 b 代替）常用的语法格式有以下 2 种。 121、(gdb) break location // b location2、(gdb) break ... if cond // b .. if cond 第一种格式中，location 用于指定打断点的具体位置，其表示方式有多种，如表 1 所示。 location的值 含义 linenum linenum 是一个整数，表示要打断点处代码的行号。要知道，程序中各行代码都有对应的行号，可通过执行 l（小写的 L）命令看到。 filename:linenum filename 表示源程序文件名；linenum 为整数，表示具体行数。整体的意思是在指令文件 filename 中的第 linenum 行打断点。 + offset- offset offset 为整数（假设值为 2），+offset 表示以当前程序暂停位置（例如第 4 行）为准，向后数 offset 行处（第 6 行）打断点；-offset 表示以当前程序暂停位置为准，向前数 offset 行处（第 2 行）打断点 function function 表示程序中包含的函数的函数名，即 break 命令会在该函数内部的开头位置打断点，程序会执行到该函数第一行代码处暂停。 filename:function filename 表示远程文件名；function 表示程序中函数的函数名。整体的意思是在指定文件 filename 中 function 函数的开头位置打断点。 第二种格式中，… 可以是表 1 中所有参数的值，用于指定打断点的具体位置；cond 为某个表达式。整体的含义为：每次程序执行到 … 位置时都计算 cond 的值，如果为 True，则程序在该位置暂停；反之，程序继续执行。另外也可以用condition 为断点设置命中条件。 tbreak和rbreak命令tbreak 命令可以看到是 break 命令的另一个版本，tbreak 和 break 命令的用法和功能都非常相似，唯一的不同在于，使用 tbreak 命令打的断点仅会作用 1 次，即使程序暂停之后，该断点就会自动消失。 和 break 和 tbreak 命令不同，rbreak 命令的作用对象是 C、C++ 程序中的函数，它会在指定函数的开头位置打断点。语法格式 1(gdb) tbreak regex 其中 regex 为一个正则表达式，程序中函数的函数名只要满足 regex 条件，tbreak 命令就会其内部的开头位置打断点。值得一提的是，tbreak 命令打的断点和 break 命令打断点的效果是一样的，会一直存在，不会自动消失。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778$ gdb test -qReading symbols from /home/zhudi/project/linux/blog/gdb/test...done.(gdb) l4 5 void cb_one() &#123;6 cout &lt;&lt; &quot;cb_one&quot; &lt;&lt; endl;7 &#125;8 void cb_second() &#123;9 cout &lt;&lt; &quot;cb_second&quot; &lt;&lt; endl;10 &#125;11 12 int main() &#123;13 int sum = 0;(gdb) 14 int n = 1;15 while (sum &lt; 100) &#123;16 sum += n;17 n++;18 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;19 sleep(1);20 cb_one();21 cb_second();22 &#125;23 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;(gdb) b 16 &lt;-- 在第16行打断点Breakpoint 1 at 0x400959: file main.cpp, line 16.(gdb) r &lt;-- 启动程序Starting program: /home/zhudi/project/linux/blog/gdb/test Breakpoint 1, main () at main.cpp:1616 sum += n; &lt;-- 在16行暂停(gdb) b +2 &lt;--在当前位置之后的2行处设置断点Breakpoint 2 at 0x400963: file main.cpp, line 18.(gdb) cContinuing.Breakpoint 2, main () at main.cpp:1818 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;(gdb) b 19 if sum&gt;2 &lt;-- 条件断点Breakpoint 3 at 0x40098c: file main.cpp, line 19.(gdb) cContinuing.sum = 1cb_onecb_secondBreakpoint 1, main () at main.cpp:1616 sum += n;(gdb) cContinuing.Breakpoint 2, main () at main.cpp:1818 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;(gdb) cContinuing.sum = 3Breakpoint 3, main () at main.cpp:1919 sleep(1);(gdb) p sum$1 = 3(gdb) rbreak cb_* &lt;-- 匹配所有以cb_开头的函数Breakpoint 4 at 0x400901: file main.cpp, line 6.void cb_one();Breakpoint 5 at 0x400923: file main.cpp, line 9.void cb_second();Breakpoint 6 at 0x400a17: file main.cpp, line 26.(gdb) cContinuing.Breakpoint 4, cb_one () at main.cpp:66 cout &lt;&lt; &quot;cb_one&quot; &lt;&lt; endl; &lt;-- 在cb_one函数的第一行暂停(gdb) cContinuing.cb_oneBreakpoint 5, cb_second () at main.cpp:99 cout &lt;&lt; &quot;cb_second&quot; &lt;&lt; endl; &lt;-- 在cb_second函数的第一行暂停 删除或禁用断点删除断点 如果之前建立的断点不再需要或者暂时不需要，该如何删除或者禁用呢？常用的方式有 2 种： 使用 quit 命令退出调试，然后重新对目标程序启动调试，此方法会将消除上一次调试操作中建立的所有断点； 使用专门删除或禁用断点的命令，既可以删除某一个断点，也可以删除全部断点。 无论是普通断点、观察断点还是捕捉断点，都可以使用 clear 或者 delete 命令进行删除。 clear 命令可以删除指定位置处的所有断点，常用的语法格式如下所示： 1(gdb) clear location 参数 location 通常为某一行代码的行号或者某个具体的函数名。当 location 参数为某个函数的函数名时，表示删除位于该函数入口处的所有断点。 delete 命令（可以缩写为 d ）通常用来删除所有断点，也可以删除指定编号的各类型断点，语法格式如下： 1delete [breakpoints] [num] 其中，breakpoints 参数可有可无，num 参数为指定断点的编号，其可以是 delete 删除某一个断点，而非全部。 如果不指定 num 参数，则 delete 命令会删除当前程序中存在的所有断点。 禁用断点 禁用断点可以使用 disable 命令，语法格式如下： 1disable [breakpoints] [num...] breakpoints 参数可有可无；num... 表示可以有多个参数，每个参数都为要禁用断点的编号。如果指定 num...，disable 命令会禁用指定编号的断点；反之若不设定 num...，则 disable 会禁用当前程序中所有的断点。 对于禁用的断点，可以使用 enable 命令激活，该命令的语法格式有多种，分别对应有不同的功能： 1234enable [breakpoints] [num...] 激活用 num... 参数指定的多个断点，如果不设定 num...，表示激活所有禁用的断点enable [breakpoints] once num… 临时激活以 num... 为编号的多个断点，但断点只能使用 1 次，之后会自动回到禁用状态enable [breakpoints] count num... 临时激活以 num... 为编号的多个断点，断点可以使用 count 次，之后进入禁用状态enable [breakpoints] delete num… 激活 num.. 为编号的多个断点，但断点只能使用 1 次，之后会被永久删除。 其中，breakpoints 参数可有可无；num... 表示可以提供多个断点的编号，enable 命令可以同时激活多个断点。 观察断点监控变量值的变化观察断点要知道，GDB 调试器支持在程序中打 3 种断点，分别为普通断点、观察断点和捕捉断点。其中 break 命令打的就是普通断点，而 watch 命令打的为观察断点。 使用 GDB 调试程序的过程中，借助观察断点可以监控程序中某个变量或者表达式的值，只要发生改变，程序就会停止执行。相比普通断点，观察断点不需要我们预测变量（表达式）值发生改变的具体位置 1(gdb) watch cond 和 watch 命令功能相似的，还有 rwatch 和 awatch 命令。其中： rwatch 命令：只要程序中出现读取目标变量（表达式）的值的操作，程序就会停止运行； awatch 命令：只要程序中出现读取目标变量（表达式）的值或者改变值的操作，程序就会停止运行。 示例1234567891011121314151617181920212223242526272829$ gdb test -qReading symbols from /home/zhudi/project/linux/blog/gdb/test...done.(gdb) startTemporary breakpoint 1 at 0x400949: file main.cpp, line 13.Starting program: /home/zhuyong/project/linux/blog/gdb/test Temporary breakpoint 1, main () at main.cpp:1313 int sum = 0;(gdb) l8 void cb_second() &#123;9 cout &lt;&lt; &quot;cb_second&quot; &lt;&lt; endl;10 &#125;11 12 int main() &#123;13 int sum = 0;14 int n = 1;15 while (sum &lt; 100) &#123;16 sum += n;17 n++;(gdb) watch sum &lt;-- 设置观察断点Hardware watchpoint 2: sum(gdb) cContinuing.Hardware watchpoint 2: sumOld value = 0New value = 1main () at main.cpp:1717 n++; &lt;-- sum值发生变化，程序暂停 查看变量或表达式的值对于在调试期间查看某个变量或表达式的值，GDB 调试器提供有 2 种方法，即使用 print 命令或者 display 命令。 print 命令它的功能就是在 GDB 调试程序的过程中，输出或者修改指定变量或者表达式的值。 print 命令可以缩写为 p，最常用的语法格式如下所示： 12(gdb) print num(gdb) p num 其中，参数 num 用来代指要查看或者修改的目标变量或者表达式。 当程序中包含多个作用域不同但名称相同的变量或表达式时，可以借助::运算符明确指定要查看的目标变量或表达式。::运算符的语法格式如下： 12(gdb) print file::variable(gdb) print function::variable 其中 file 用于指定具体的文件名，funciton 用于指定具体所在函数的函数名，variable 表示要查看的目标变量或表达式。 另外，print也可以打印出类或者结构体变量的值。 display 命令和 print 命令一样，display 命令也用于调试阶段查看某个变量或表达式的值，它们的区别是，使用 display 命令查看变量或表达式的值，每当程序暂停执行（例如单步执行）时，GDB 调试器都会自动帮我们打印出来，而 print 命令则不会。 也就是说，使用 1 次 print 命令只能查看 1 次某个变量或表达式的值，而同样使用 1 次 display 命令，每次程序暂停执行时都会自动打印出目标变量或表达式的值。因此，当我们想频繁查看某个变量或表达式的值从而观察它的变化情况时，使用 display 命令可以一劳永逸。 display 命令没有缩写形式，常用的语法格式如下 2 种： 12(gdb) display expr(gdb) display/fmt expr 注意，display 命令和 &#x2F;fmt 之间不要留有空格。以 &#x2F;x 为例，应写为 (gdb)display&#x2F;x expr。 GDB单步调试根据实际场景的需要，GDB 调试器共提供了 3 种可实现单步调试程序的方法，即使用 next、step 和 until 命令。换句话说，这 3 个命令都可以控制 GDB 调试器每次仅执行 1 行代码，但除此之外，它们各自还有不同的功能。 next命令next 是最常用来进行单步调试的命令，其最大的特点是当遇到包含调用函数的语句时，无论函数内部包含多少行代码，next 指令都会一步执行完。也就是说，对于调用的函数来说，next 命令只会将其视作一行代码。 next 命令可以缩写为 n 命令，使用方法也很简单，语法格式如下： 1(gdb) next count step命令通常情况下，step 命令和next命令的功能相同，都是单步执行程序。不同之处在于，当 step 命令所执行的代码行中包含函数时，会进入该函数内部，并在函数第一行代码处停止执行。 step 命令可以缩写为 s 命令，用法和 next 命令相同，语法格式如下： 1(gdb) step count until命令until 命令可以简写为 u 命令，有 2 种语法格式，如下所示： 121、(gdb) until2、(gdb) until location 其中，参数 location 为某一行代码的行号。 不带参数的 until 命令，可以使 GDB 调试器快速运行完当前的循环体，并运行至循环体外停止。注意，until 命令并非任何情况下都会发挥这个作用，只有当执行至循环体尾部（最后一行代码）时，until 命令才会发生此作用；反之，until 命令和 next 命令的功能一样，只是单步执行程序。 return命令实际调试时，在某个函数中调试一段时间后，可能不需要再一步步执行到函数返回处，希望直接执行完当前函数，这时可以使用 finish 命令。与 finish 命令类似的还有 return 命令，它们都可以结束当前执行的函数。 finish命令finish 命令和 return 命令的区别是，finish 命令会执行函数到正常退出；而 return 命令是立即结束执行当前函数并返回，也就是说，如果当前函数还有剩余的代码未执行完毕，也不会执行了。除此之外，return 命令还有一个功能，即可以指定该函数的返回值。 jump命令jump 命令的功能是直接跳到指定行继续执行程序，其语法格式为： 1(gdb) jump location 其中，location 通常为某一行代码的行号。 也就是说，jump 命令可以略过某些代码，直接跳到 location 处的代码继续执行程序。这意味着，如果你跳过了某个变量（对象）的初始化代码，直接执行操作该变量（对象）的代码，很可能会导致程序崩溃或出现其它 Bug。另外，如果 jump 跳转到的位置后续没有断点，那么 GDB 会直接执行自跳转处开始的后续代码。 GDB search 命令调试文件时，某些时候可能会去找寻找某一行或者是某一部分的代码。可以使用 list 显示全部的源码，然后进行查看。当源文件的代码量较少时，我们可以使用这种方式搜索。如果源文件的代码量很大，使用这种方式寻找效率会很低。所以 GDB 中提供了相关的源代码搜索的的search命令。 search 命令的语法格式为： 12search &lt;regexp&gt;reverse-search &lt;regexp&gt; 第一项命令格式表示从当前行的开始向前搜索，后一项表示从当前行开始向后搜索。其中 regexp 就是正则表达式，正则表达式描述了一种字符串匹配的模式，可以用来检查一个串中是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串。很多的编程语言都支持使用正则表达式。 查看堆栈信息backtrace 命令backtrace 命令用于打印当前调试环境中所有栈帧的信息，常用的语法格式如下： 1(gdb) backtrace [-full] [n] 其中，用 [ ] 括起来的参数为可选项，它们的含义分别为： n：一个整数值，当为正整数时，表示打印最里层的 n 个栈帧的信息；n 为负整数时，那么表示打印最外层n个栈帧的信息； -full：打印栈帧信息的同时，打印出局部变量的值。 注意，当调试多线程程序时，该命令仅用于打印当前线程中所有栈帧的信息。如果想要打印所有线程的栈帧信息，应执行thread apply all backtrace命令。 frame 命令frame 命令的常用形式有 2 个： 根据栈帧编号或者栈帧地址，选定要查看的栈帧，语法格式如下： 1(gdb) frame spec 该命令可以将 spec 参数指定的栈帧选定为当前栈帧。spec 参数的值，常用的指定方法有 3 种： 通过栈帧的编号指定。0 为当前被调用函数对应的栈帧号，最大编号的栈帧对应的函数通常就是 main() 主函数； 借助栈帧的地址指定。栈帧地址可以通过 info frame 命令（后续会讲）打印出的信息中看到； 通过函数的函数名指定。注意，如果是类似递归函数，其对应多个栈帧的话，通过此方法指定的是编号最小的那个栈帧。 除此之外，对于选定一个栈帧作为当前栈帧，GDB 调试器还提供有 up 和down两个命令。其中，up 命令的语法格式为： 1(gdb) up n 其中 n 为整数，默认值为 1。该命令表示在当前栈帧编号（假设为 m）的基础上，选定 m+n 为编号的栈帧作为新的当前栈帧。 相对地，down 命令的语法格式为： 1(gdb) down n 其中n为整数，默认值为 1。该命令表示在当前栈帧编号（假设为 m）的基础上，选定 m-n 为编号的栈帧作为新的当前栈帧。 借助如下命令，我们可以查看当前栈帧中存储的信息： 1(gdb) info frame 该命令会依次打印出当前栈帧的如下信息： 当前栈帧的编号，以及栈帧的地址； 当前栈帧对应函数的存储地址，以及该函数被调用时的代码存储的地址 当前函数的调用者，对应的栈帧的地址； 编写此栈帧所用的编程语言； 函数参数的存储地址以及值； 函数中局部变量的存储地址； 栈帧中存储的寄存器变量，例如指令寄存器（64位环境中用 rip 表示，32为环境中用 eip 表示）、堆栈基指针寄存器（64位环境用 rbp 表示，32位环境用 ebp 表示）等。 除此之外，还可以使用info args命令查看当前函数各个参数的值；使用info locals命令查看当前函数中各局部变量的值。 调试正在执行的程序如果调试正在执行中的程序，首先需要找到正在运行程序的进程号PID，之后可以用下面三个命令进行调试，进入正常的调试流程。 1231) gdb attach PID2) gdb 文件名 PID3) gdb -p PID 示例：12345678910111213141516171819# ps -aux | grep test &lt;-- 找到正在运行程序的进程号PIDroot 17997 0.0 0.0 12540 1064 pts/0 S+ 10:19 0:00 ./testroot 18088 0.0 0.0 112812 972 pts/1 S+ 10:20 0:00 grep --color=auto test # gdb attach 17997 -q &lt;-- 用gdb进行调试attach: No such file or directory.Attaching to process 17997Reading symbols from /root/project/blog/gdb/test...done.Reading symbols from /lib64/libstdc++.so.6...(no debugging symbols found)...done.Loaded symbols for /lib64/libstdc++.so.6Reading symbols from /lib64/libm.so.6...(no debugging symbols found)...done.Loaded symbols for /lib64/libm.so.6Reading symbols from /lib64/libgcc_s.so.1...(no debugging symbols found)...done.Loaded symbols for /lib64/libgcc_s.so.1Reading symbols from /lib64/libc.so.6...(no debugging symbols found)...done.Loaded symbols for /lib64/libc.so.6Reading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.Loaded symbols for /lib64/ld-linux-x86-64.so.20x00007f61ea02b840 in __nanosleep_nocancel () from /lib64/libc.so.6 注意，当 GDB 调试器成功连接到指定进程上时，程序执行会暂停。如上所示，程序暂停至第 6 行代码num++的位置，此时可以通过断点调试、逐步运行等方式监控程序的执行过程。例如： 12345678910111213141516171819202122232425262728293031323334353637383940(gdb) l warning: Source file is more recent than executable.1 #include &lt;iostream&gt;2 #include &lt;unistd.h&gt;3 using namespace std;4 5 int main() &#123;6 int sum = 0;7 int n = 1;8 while (true) &#123;9 sum += n;10 n++;(gdb) 11 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;12 sleep(1);13 &#125;14 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;15 16 return 0;17 &#125;18 (gdb) b 10Breakpoint 1 at 0x400869: file main.cpp, line 10.(gdb) cContinuing.Breakpoint 1, main () at main.cpp:1010 n++;(gdb) p sum$1 = 2145(gdb) cContinuing.Breakpoint 1, main () at main.cpp:1010 n++;(gdb) p sum$2 = 2211(gdb) 注意，当调试完成后，如果想令当前程序进行执行，消除调试操作对它的影响，需手动将 GDB 调试器与程序分离，分离过程分为 2 步： 执行 detach 指令，使GDB调试器和程序分离； 执行 quit（或 q）指令，退出GDB调试。 调试执行异常崩溃的程序在Linux操作系统中，当程序执行发生异常崩溃时，系统可以将发生崩溃时的内存数据、调用堆栈情况等信息自动记录下载，并存储到一个文件中，该文件通常称为 core 文件，Linux 系统所具备的这种功能又称为核心转储（core dump）。幸运的是，GDB 对 core 文件的分析和调试提供有非常强大的功能支持，当程序发生异常崩溃时，通过 GDB 调试产生的 core 文件，往往可以更快速的解决问题。 这里就先不写如何设置core dump文件目录了，可以自行了解。 写个程序验证一下： 12345678#include &lt;stdio.h&gt;int main() &#123; char *a = NULL; *a = 2; return 0;&#125; 编译运行 123$ g++ -g -o test core.cpp $ ./testSegmentation fault (core dumped) &lt;-- 发生段错误，并生成了 core 文件 可以根据生成时间查找core dump文件 123456ls /home/homework/coresave -hl | grep test-rw-rw-rw- 1 root root 400K Mar 13 15:08 core.test.27725.1615619332-rw-rw-rw- 1 root root 400K Mar 13 15:26 core.test.7791.1615620408-rw-rw-rw- 1 root root 540K Mar 11 10:29 core.test.1868.1615429740-rw-rw-rw- 1 root root 400K Mar 13 15:07 core.test.26880.1615619264-rw-rw-rw- 1 root root 404K Mar 3 19:42 core.test.28802.1614771771 用gdb进行调试 123456789$ gdb test /home/homework/coresave/core.test1.7791.1615620408 -qReading symbols from /home/zhudi/project/linux/blog/gdb/test...done.warning: core file may not match specified executable file.[New LWP 7791]Core was generated by `./test&#x27;.Program terminated with signal 11, Segmentation fault.#0 0x00000000004005bd in main () at core.cpp:55 *a = 2; 由此可见，程序崩溃了在第五行，定位到了出现问题的代码位置。 本文参考 GDB调试教程 本文作者：zhuyong 原文链接：https://zhuyongchn.github.io 关于博主：欢迎关注左侧公众号，获取更多干货。 版权声明：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！","categories":[],"tags":[]},{"title":"sdp(会话传输协议)详解","slug":"webrtc sdp(会话传输协议)详解","date":"2021-02-08T12:09:59.000Z","updated":"2021-02-09T11:38:11.787Z","comments":true,"path":"2021/02/08/webrtc sdp(会话传输协议)详解/","link":"","permalink":"http://example.com/2021/02/08/webrtc%20sdp(%E4%BC%9A%E8%AF%9D%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"1、什么是sdpSDP(Session Description Protocol)描述会话协议，它只是一种信息格式的描述标准，本身不属于传输协议，但是可以被其他传输协议用来交换必要的信息，用于两个会话实体之间的媒体协商。 2、sdp协议结构SDP的文本信息包括： 会话信息 网络信息 媒体信息 安全信息 服务质量和分组信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 +---------------------+ | v= | +---------------------+ +---------------------+ +---------------------+ ==== | Session Metadata | ===== | o= | | +---------------------+ +---------------------- | +---------------------+ | | t= | | +---------------------+ | | | +---------------------+ | | c= | | +---------------------+ | +---------------------+ ==== | Network Description | ===== | +---------------------+ | +---------------------+ | | a=candidate | | +---------------------+ | | | +---------------------+ | | m= | | +---------------------+ | +---------------------+ +---------------------+ ==== | Stream Description | ===== | a=rtpmap | | +---------------------+ +---------------------- | +---------------------+ | | a=fmtp | | +---------------------+ | +---------------------+ | | a=sendrecv.. | | +---------------------++---------------+| SEMANTIC || COMPONENTS OF || SDP |+---------------+ | +---------------------+ | | a=crypto | | +---------------------+ | +---------------------+ +---------------------+ ==== |Security Descriptions| =====| a=ice-frag | | +---------------------+ +---------------------- | +---------------------+ | | a=ice-pwd | | +---------------------+ | +---------------------+ | | a=fingerprint | | +---------------------+ | | | | +---------------------+ | | a=rtcp-fb | | +---------------------+ | +---------------------+ +---------------------+ ==== | Qos,Grouping | | | | Descriptions | =====| a=group | +---------------------+ +---------------------- +---------------------+ | a=rtcpmux | +---------------------+ sdp格式SDP描述由许多文本行组成，文本行的格式为&lt;类型&gt;&#x3D;&lt;值&gt;，&lt;类型&gt;是一个字母，&lt;值&gt;是结构化的文本串，其格式依&lt;类型&gt;而定，每个SDP有一个会话级描述、多个媒体级描述。 1234567&lt;type&gt;=&lt;value&gt;&lt;type&gt;: 区分大小写，代表特定的属性，例如v代表SDP版本。&lt;value&gt;：UTF8编码的文本，具体格式与类型有关。=两边不允许存在空格。=*表示该项是可选的。 会话的名称和目的 Session Description v &#x3D; （协议版本）o &#x3D; （所有者&#x2F;创建者和会话标识符）s &#x3D; （会话名称）i &#x3D; * （会话信息）u &#x3D; * （URI 描述）e &#x3D; * （Email 地址）p &#x3D; * （电话号码）c &#x3D; * （连接信息 ― 如果包含在所有媒体中，则不需要该字段）b &#x3D; * （带宽信息） 会话存活时间 Time Description t &#x3D; （会话活动时间）r &#x3D; * （0或多次重复次数） 构成会话的媒体(会话中包括多个媒体)SDP的媒体信息 Media Description媒体格式传输协议传输IP和端口媒体负载类型(VP8、VP9、H264、H265) m &#x3D; （媒体名称和传输地址）i &#x3D; * （媒体标题）c &#x3D; * （连接信息 — 如果包含在会话层则该字段可选）b &#x3D; * （带宽信息）k &#x3D; * （加密密钥）a &#x3D; * （0 个或多个会话属性行） 3、sdp实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175 【Session Metadata部分】v=0//sdp版本号，一直为0,rfc4566规定o=- 7017624586836067756 2 IN IP4 127.0.0.1//origion/owner o=&lt;username&gt; &lt;session id&gt; &lt;version&gt; &lt;network type&gt; &lt;address type&gt; &lt;unicast-address&gt;//username如何没有使用-代替，7017624586836067756是整个会话的编号，2代表会话版本，如果在会话//过程中有改变编码之类的操作，重新生成sdp时,sess-id不变，sess-version加1s=-//会话名,必选，没有的话使用-代替t=0 0//两个值分别是会话的起始时间和结束时间，这里都是0代表没有限制a=group:BUNDLE audio video data//需要共用一个传输通道传输的媒体，如果没有这一行，音视频，数据就会分别单独用一个udp端口来发送a=msid-semantic: WMS h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C//WMS是WebRTC Media Stream简称，这一行定义了本客户端支持同时传输多个流，一个流可以包括多个track,//一般定义了这个，后面a=ssrc这一行就会有msid,mslabel等属性 【Stream Description部分】 【audio部分】 m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 126//m = &lt;media&gt;&lt;port&gt;&lt;transport&gt;&lt;fmt/payload type list&gt;//m=audio说明本会话包含音频，9代表音频使用端口9来传输，但是在webrtc中一现在一般不使用，如果设置为0，代表不//传输音频,UDP/TLS/RTP/SAVPF是表示用户来传输音频支持的协议，udp，tls,rtp代表使用udp来传输rtp包，并使用tls加密//SAVPF代表使用srtcp的反馈机制来控制通信过程,后台111 103 104 9 0 8 106 105 13 126表示本会话音频支持的编码，后台几行会有详细补充说明c=IN IP4 0.0.0.0//这一行表示你要用来接收或者发送音频使用的IP地址，webrtc使用ice传输，不使用这个地址a=rtcp:9 IN IP4 0.0.0.0//用来传输rtcp地地址和端口，webrtc中不使用a=ice-ufrag:khLSa=ice-pwd:cxLzteJaJBou3DspNaPsJhlQ//以上两行是ice协商过程中的安全验证信息a=fingerprint:sha-256 FA:14:42:3B:C7:97:1B:E8:AE:0C2:71:03:05:05:16:8F:B9:C7:98:E9:60:43:4B:5B:2C:28:EE:5C:8F3:17//以上这行是dtls协商过程中需要的认证信息a=setup:actpass//以上这行代表本客户端在dtls协商过程中，可以做客户端也可以做服务端，参考rfc4145 rfc4572a=mid:audio//在前面BUNDLE这一行中用到的媒体标识a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level//上一行指出我要在rtp头部中加入音量信息，参考 rfc6464a=sendrecv//上一行指出我是双向通信，另外几种类型是recvonly,sendonly,inactivea=rtcp-mux//上一行指出rtp,rtcp包使用同一个端口来传输//下面几行都是对m=audio这一行的媒体编码补充说明，指出了编码采用的编号，采样率，声道等a=rtpmap:111 opus/48000/2//可选 a=rtpmap:&lt;fmt/payload type&gt;&lt;encoding name&gt;/&lt;clock rate&gt;[/&lt;encodingparameters&gt;]a=rtcp-fb:111 transport-cc//以上这行说明opus编码支持使用rtcp来控制拥塞，参考https://tools.ietf.org/html/draft-holmer-rmcat-transport-wide-cc-extensions-01a=fmtp:111 minptime=10;useinbandfec=1//可选 a=fmtp:&lt;fmt/payload type&gt; parameters 对rtpmap进一步说明//对opus编码可选的补充说明,minptime代表最小打包时长是10ms，useinbandfec=1代表使用opus编码内置fec特性a=rtpmap:103 ISAC/16000a=rtpmap:104 ISAC/32000a=rtpmap:9 G722/8000a=rtpmap:0 PCMU/8000a=rtpmap:8 PCMA/8000a=rtpmap:106 CN/32000a=rtpmap:105 CN/16000a=rtpmap:13 CN/8000a=rtpmap:126 telephone-event/8000a=ssrc:18509423 cname:sTjtznXLCNH7nbRw//cname用来标识一个数据源，ssrc当发生冲突时可能会发生变化，但是cname不会发生变化，也会出现在rtcp包中SDEC中，//用于音视频同步a=ssrc:18509423 msid:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C 15598a91-caf9-4fff-a28f-3082310b2b7a//以上这一行定义了ssrc和WebRTC中的MediaStream,AudioTrack之间的关系，msid后面第一个属性是stream-d,第二个是track-ida=ssrc:18509423 mslabel:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97Ca=ssrc:18509423 label:15598a91-caf9-4fff-a28f-3082310b2b7a 【video部分】 m=video 9 UDP/TLS/RTP/SAVPF 100 101 107 116 117 96 97 99 98//参考上面m=audio,含义类似c=IN IP4 0.0.0.0a=rtcp:9 IN IP4 0.0.0.0a=ice-ufrag:khLSa=ice-pwd:cxLzteJaJBou3DspNaPsJhlQa=fingerprint:sha-256 FA:14:42:3B:C7:97:1B:E8:AE:0C2:71:03:05:05:16:8F:B9:C7:98:E9:60:43:4B:5B:2C:28:EE:5C:8F3:17a=setup:actpassa=mid:videoa=extmap:2 urn:ietf:params:rtp-hdrext:toffseta=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-timea=extmap:4 urn:3gpp:video-orientationa=extmap:5 http://www.ietf.org/id/draft-hol ... de-cc-extensions-01a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/playout-delaya=sendrecva=rtcp-muxa=rtcp-rsizea=rtpmap:100 VP8/90000a=rtcp-fb:100 ccm fir//ccm是codec control using RTCP feedback message简称，意思是支持使用rtcp反馈机制来实现编码控制，fir是Full Intra Request//简称，意思是接收方通知发送方发送幅完全帧过来a=rtcp-fb:100 nack//支持丢包重传，参考rfc4585a=rtcp-fb:100 nack pli//支持关键帧丢包重传,参考rfc4585a=rtcp-fb:100 goog-remb//支持使用rtcp包来控制发送方的码流a=rtcp-fb:100 transport-cc//参考上面opusa=rtpmap:101 VP9/90000a=rtcp-fb:101 ccm fira=rtcp-fb:101 nacka=rtcp-fb:101 nack plia=rtcp-fb:101 goog-remba=rtcp-fb:101 transport-cca=rtpmap:107 H264/90000a=rtcp-fb:107 ccm fira=rtcp-fb:107 nacka=rtcp-fb:107 nack plia=rtcp-fb:107 goog-remba=rtcp-fb:107 transport-cca=fmtp:107 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f//h264编码可选的附加说明a=rtpmap:116 red/90000//fec冗余编码，一般如果sdp中有这一行的话，rtp头部负载类型就是116，否则就是各编码原生负责类型a=rtpmap:117 ulpfec/90000//支持ULP FEC，参考rfc5109a=rtpmap:96 rtx/90000a=fmtp:96 apt=100//以上两行是VP8编码的重传包rtp类型a=rtpmap:97 rtx/90000a=fmtp:97 apt=101a=rtpmap:99 rtx/90000a=fmtp:99 apt=107a=rtpmap:98 rtx/90000a=fmtp:98 apt=116a=ssrc-group:FID 3463951252 1461041037//在webrtc中，重传包和正常包ssrc是不同的，上一行中前一个是正常rtp包的ssrc,后一个是重传包的ssrca=ssrc:3463951252 cname:sTjtznXLCNH7nbRwa=ssrc:3463951252 msid:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C ead4b4e9-b650-4ed5-86f8-6f5f5806346da=ssrc:3463951252 mslabel:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97Ca=ssrc:3463951252 label:ead4b4e9-b650-4ed5-86f8-6f5f5806346da=ssrc:1461041037 cname:sTjtznXLCNH7nbRwa=ssrc:1461041037 msid:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97C ead4b4e9-b650-4ed5-86f8-6f5f5806346da=ssrc:1461041037 mslabel:h1aZ20mbQB0GSsq0YxLfJmiYWE9CBfGch97Ca=ssrc:1461041037 label:ead4b4e9-b650-4ed5-86f8-6f5f5806346dm=application 9 DTLS/SCTP 5000c=IN IP4 0.0.0.0a=ice-ufrag:khLSa=ice-pwd:cxLzteJaJBou3DspNaPsJhlQa=fingerprint:sha-256 FA:14:42:3B:C7:97:1B:E8:AE:0C2:71:03:05:05:16:8F:B9:C7:98:E9:60:43:4B:5B:2C:28:EE:5C:8F3:17a=setup:actpassa=mid:dataa=sctpmap:5000 webrtc-datachannel 1024 WebRTC核心之SDP详解、媒体协商 WebRTC – SDP格式解析 WebRTC会话描述协议（SDP）详解 本文作者：zhuyong 原文链接：https://zhuyongchn.github.io 关于博主：欢迎关注左侧公众号，获取更多干货。 版权声明：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！","categories":[],"tags":[]},{"title":"valgrind和Kcachegrind性能分析工具详解","slug":"valgrind和Kcachegrind性能分析工具详解","date":"2021-02-02T10:57:15.000Z","updated":"2021-02-09T11:38:11.790Z","comments":true,"path":"2021/02/02/valgrind和Kcachegrind性能分析工具详解/","link":"","permalink":"http://example.com/2021/02/02/valgrind%E5%92%8CKcachegrind%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"一、valgrind介绍valgrind是运行在Linux上的一套基于仿真技术的程序调试和分析工具，用于构建动态分析工具的装备性框架。它包括一个工具集，每个工具执行某种类型的调试、分析或类似的任务，以帮助完善你的程序。Valgrind的架构是模块化的，所以可以容易的创建新的工具而又不会扰乱现有的结构。 valgrind主要包含以下工具： 123456789101、memcheck：检查程序中的内存问题，如泄漏、越界、非法指针等。2、callgrind：检测程序代码的运行时间和调用过程，以及分析程序性能。3、cachegrind：分析CPU的cache命中率、丢失率，用于进行代码优化。4、helgrind：用于检查多线程程序的竞态条件。5、massif：堆栈分析器，指示程序中使用了多少堆内存等信息。 另外，也有一些大多数用户不会用到的小工具： Lackey是一个示例工具，用于演示一些装备的基础性内容；Nulgrind是一个最小化的Valgrind工具，不做分析或者操作，仅用于测试目的。 二、valgrind安装及使用安装建议从valgrind官网下载安装，目前官网的最新包是3.16.1 123456$ mkdir valgrind-inst$ cd valgrind-inst/$ wget https://sourceware.org/pub/valgrind/valgrind-3.16.1.tar.bz2$ lsvalgrind-3.16.1.tar.bz2 解压后进行安装，可以指定安装目录，这样的话记得设置环境变量 12345$ tar -xvf valgrind-3.16.1.tar.bz2$ cd valgrind-3.16.1$ ./configure --prefix=/usr/local/valgrind$ make$ make install 查看是否安装成功 12$ valgrind --versionvalgrind-3.16.1 工具集的使用基本使用格式如下： 1usage: valgrind [options] prog-and-args 其支持众多选项，我们可以通过valgrind --help来进行查看。 这里我们只介绍几个较为常用的选项 1234567891011121314151617181920212223242526--tool: 是最常用的选项，用于选择使用valgrind工具集中的哪一个工具。默认值为memcheck。--version: 用于打印valgrind的版本号-q/--quiet: 安静的运行，只打印错误消息；-v/--verbose: 打印更详细的信息；--trace-children: 是否跟踪子进程，默认值为no;--track-fds: 是否追踪打开的文件描述符，默认为no--time-stamp=no|yes: 是否在打印出的每条消息之前加上时间戳信息。默认值为no--log-file=&lt;file&gt;: 指定将消息打印到某个文件--default-suppressions: 加载默认的抑制参数。--alignment: 指定malloc分配内存时的最小对齐字节数；如下的一些选项用于Memcheck工具：--leak-check=no|summary|full: 在退出时是否查找内存泄露。默认值为summary--show-leak-kinds=kind1,kind2,..: 显示哪一种类型的内存泄露。默认显示definite和possible这两种； 三、 Valgrind 工具详解1） memcheck最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到，一切对malloc、free、new、delete的调用都会被捕获。所以，它能检测以下问题： 12345678910111213141、使用未初始化的内存。如果在定义一个变量时没有赋初始值，后边即使赋值了，使用这个变量的时候Memcheck也会报&quot;uninitialised value&quot;错误。使用中会发现，valgrind提示很多这个错误，由于关注的是内存泄漏问题，所以可以用--undef-value-errors=选项把这个错误提示屏蔽掉，具体可以看后面的选项解释。2、读/写释放后的内存块；3、内存读写越界（数组访问越界／访问已经释放的内存),读/写超出malloc分配的内存块；4、读/写不适当的栈中内存块；5、内存泄漏，指向一块内存的指针永远丢失；6、不正确的malloc/free或new/delete匹配（重复释放／使用不匹配的分配和释放函数）；7、内存覆盖，memcpy()相关函数中的dst和src指针重叠。 用法： 将程序编译生成可执行文件后执行：valgrind –leak-check=full ./程序名 注意：下面讨论的所有测试代码在编译时最好都加上-g选项（用来在memcheck的输出中生成行号）进行编译。 测试程序验证： 编写测试程序 123456789101112#include &lt;stdlib.h&gt;void func() &#123; char *p = new char[10];&#125;int main() &#123; func(); return 0;&#125; 编译后，用valgrind检测程序。如果设置了--leak-check=full，Memcheck会给出详细的每个块是在哪里分配，并且给出分配时函数调用堆栈（编译的时候使用-g选项和去掉-o优化选项，就可以得到更详细的函数信息，可以精确到代码的某一行）。可以通过--show-leak-kinds选项来选择要详细报告哪几种类型的错误。Memcheck会把函数调用堆栈相同或相似的内存块信息，放到同一个条目来显示，可以通过--leak-resolution来控制这个”相似”判断的力度。 12$ g++ -g -o test leak.cpp$ valgrind --tool=memcheck --leak-check=full ./test 检测结果如下： 123456789101112131415161718192021222324==6018== Memcheck, a memory error detector==6018== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.==6018== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info==6018== Command: ./test==6018== ==6018== ==6018== HEAP SUMMARY:==6018== in use at exit: 10 bytes in 1 blocks==6018== total heap usage: 1 allocs, 0 frees, 10 bytes allocated==6018== ==6018== 10 bytes in 1 blocks are definitely lost in loss record 1 of 1==6018== at 0x4C2AC58: operator new[](unsigned long) (vg_replace_malloc.c:431)==6018== by 0x40062E: func() (leak.cpp:4)==6018== by 0x40063D: main (leak.cpp:8)==6018== ==6018== LEAK SUMMARY:==6018== definitely lost: 10 bytes in 1 blocks==6018== indirectly lost: 0 bytes in 0 blocks==6018== possibly lost: 0 bytes in 0 blocks==6018== still reachable: 0 bytes in 0 blocks==6018== suppressed: 0 bytes in 0 blocks==6018== ==6018== For lists of detected and suppressed errors, rerun with: -s==6018== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) 结果说明： 先看看输出信息中的HEAP SUMMARY，它表示程序在堆上分配内存的情况，其中的1 allocs表示程序分配了 1 次内存，0 frees表示程序释放了 0 次内存，10 bytes allocated表示分配了 10 个字节的内存。另外，Valgrind 也会报告程序是在哪个位置发生内存泄漏。 上面LEAK SUMMARY会打印5种不同的类型，这里我们简单介绍一下： 12345678definitely lost: 明确丢失的内存。程序中存在内存泄露，应尽快修复。当程序结束时如果一块动态分配的内存没有被释放并且通过程序内的指针变量均无法访问这块内存则会报这个错误；indirectly lost: 间接丢失。当使用了含有指针成员的类或结构体时可能会报这个错误。这类错误无需直接修复，它们总是与definitely lost一起出现，只要修复definitely lost即可。possibly lost: 可能丢失。大多数情况下应视为与definitely lost一样需要尽快修复，除非你的程序让一个指针指向一块动态分配的内存（但不是这块内存的起始地址），然后通过运算得到这块内存的起始地址，再释放它。当程序结束时如果一块动态分配的内存没有被释放并且通过程序内的指针变量均无法访问这块内存的起始地址，但可以访问其中的某一部分数据，则会报这个错误。stil reachable: 可以访问，未丢失但也未释放。如果程序是正常结束的，那么它可能不会造成程序崩溃，但长时间运行有可能耗尽系统资源。 其他几种情况，写一个综合的测试程序进行验证。 1234567891011121314151617181920// mixed.cppvoid func() &#123; char *ptr = new char[10]; ptr[10] = &#x27;a&#x27;; // 内存越界 memcpy(ptr + 1, ptr, 5); // 踩内存 delete []ptr; delete []ptr; // 重复释放 char *p; *p = 1; // 非法指针&#125;int main() &#123; func(); return 0;&#125; 编译后，用valgrind检测程序。 12$ g++ -g -o test mixed.cpp$ valgrind --tool=memcheck --leak-check=full ./test 检测结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051==22786== Memcheck, a memory error detector==22786== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.==22786== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info==22786== Command: ./test==22786== ==22786== Invalid write of size 1 // 内存越界==22786== at 0x4007FB: func() (mixed.cpp:6)==22786== by 0x400851: main (mixed.cpp:18)==22786== Address 0x5a2404a is 0 bytes after a block of size 10 alloc&#x27;d==22786== at 0x4C2AC58: operator new[](unsigned long) (vg_replace_malloc.c:431)==22786== by 0x4007EE: func() (mixed.cpp:5)==22786== by 0x400851: main (mixed.cpp:18)==22786== ==22786== Source and destination overlap in memcpy(0x5a24041, 0x5a24040, 5) // 踩内存==22786== at 0x4C2E83D: memcpy@@GLIBC_2.14 (vg_replace_strmem.c:1033)==22786== by 0x400819: func() (mixed.cpp:8)==22786== by 0x400851: main (mixed.cpp:18)==22786== ==22786== Invalid free() / delete / delete[] / realloc() // 重复释放==22786== at 0x4C2BBAF: operator delete[](void*) (vg_replace_malloc.c:649)==22786== by 0x40083F: func() (mixed.cpp:11)==22786== by 0x400851: main (mixed.cpp:18)==22786== Address 0x5a24040 is 0 bytes inside a block of size 10 free&#x27;d==22786== at 0x4C2BBAF: operator delete[](void*) (vg_replace_malloc.c:649)==22786== by 0x40082C: func() (mixed.cpp:10)==22786== by 0x400851: main (mixed.cpp:18)==22786== Block was alloc&#x27;d at==22786== at 0x4C2AC58: operator new[](unsigned long) (vg_replace_malloc.c:431)==22786== by 0x4007EE: func() (mixed.cpp:5)==22786== by 0x400851: main (mixed.cpp:18)==22786== ==22786== Use of uninitialised value of size 8 // 非法指针==22786== at 0x400844: func() (mixed.cpp:14)==22786== by 0x400851: main (mixed.cpp:18)==22786== ==22786== ==22786== Process terminating with default action of signal 11 (SIGSEGV): dumping core==22786== Bad permissions for mapped region at address 0x4008B0==22786== at 0x400844: func() (mixed.cpp:14)==22786== by 0x400851: main (mixed.cpp:18)==22786== ==22786== HEAP SUMMARY:==22786== in use at exit: 0 bytes in 0 blocks==22786== total heap usage: 1 allocs, 2 frees, 10 bytes allocated==22786== ==22786== All heap blocks were freed -- no leaks are possible==22786== ==22786== Use --track-origins=yes to see where uninitialised values come from ==22786== For lists of detected and suppressed errors, rerun with: -s==22786== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)Segmentation fault (core dumped) 可见valgrind将上述几种情况都检测出来了。 2） Callgrind和gprof类似的分析工具，但它对程序的运行观察更为入微，能给我们提供更多的信息。和gprof不同的是，它不需要在编译源代码时附加特殊选项，但还是推荐加上调试选项。Callgrind收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。 测试程序 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void test() &#123; sleep(1);&#125;void func() &#123; for(int i = 0; i &lt; 10; i++) &#123; test(); &#125;&#125;int main() &#123; func(); printf(&quot;process is over!\\n&quot;); return 0;&#125; 编译后，用valgrind检测程序。 1234$ g++ -g -o test callgrind.cpp$ valgrind --tool=callgrind ./test$ lscallgrind.cpp callgrind.out.3490 test callgrind.out.3490就是callgrind生成的文件。 这里介绍一个图形化性能分析工具Kcachegrind Kcachegrind官网地址 下载安装后可以用来分析callgrind生成的文件。 用Kcachegrind打开callgrind.out.3490这个文件，如下图： 通过图形化，我们可以很直观的知道哪段程序执行慢，并且了解相关调用关系。 3） CachegrindCache分析器，它模拟CPU中的一级缓存和二级缓存，能够精确地指出程序中cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。 它的使用方法也是：valgrind –tool=cachegrind ./程序名 4） Helgrind它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发觉的错误。Helgrind实现了名为Eraser的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，Helgrind仍然处于实验状态。 测试代码： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#define NUM 10int counter = 0;void *threadfunc(void*) &#123; for (int i = 0; i &lt; NUM; i++) &#123; counter += i; &#125;&#125;int main() &#123; pthread_t tid1, tid2; pthread_create(&amp;tid1, NULL, &amp;threadfunc, NULL); pthread_create(&amp;tid2, NULL, &amp;threadfunc, NULL); // wait for thread to terminate pthread_join(tid1, NULL); pthread_join(tid2, NULL); printf(&quot;counter = %d\\n&quot;, counter); return 0;&#125; 编译后，用valgrind检测程序。 12$ g++ -g -o test helgrind.cpp -lpthread$ valgrind --tool=helgrind ./test 检测结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465==27722== Helgrind, a thread error detector==27722== Copyright (C) 2007-2017, and GNU GPL&#x27;d, by OpenWorks LLP et al.==27722== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info==27722== Command: ./test==27722== ==27722== ---Thread-Announcement------------------------------------------==27722== ==27722== Thread #3 was created==27722== at 0x597589E: clone (in /usr/lib64/libc-2.17.so)==27722== by 0x4E43059: do_clone.constprop.4 (in /usr/lib64/libpthread-2.17.so)==27722== by 0x4E44569: pthread_create@@GLIBC_2.2.5 (in /usr/lib64/libpthread-2.17.so)==27722== by 0x4C30CFA: pthread_create_WRK (hg_intercepts.c:425)==27722== by 0x4C31DD8: pthread_create@* (hg_intercepts.c:458)==27722== by 0x400728: main (helgrind.cpp:17)==27722== ==27722== ---Thread-Announcement------------------------------------------==27722== ==27722== Thread #2 was created==27722== at 0x597589E: clone (in /usr/lib64/libc-2.17.so)==27722== by 0x4E43059: do_clone.constprop.4 (in /usr/lib64/libpthread-2.17.so)==27722== by 0x4E44569: pthread_create@@GLIBC_2.2.5 (in /usr/lib64/libpthread-2.17.so)==27722== by 0x4C30CFA: pthread_create_WRK (hg_intercepts.c:425)==27722== by 0x4C31DD8: pthread_create@* (hg_intercepts.c:458)==27722== by 0x40070D: main (helgrind.cpp:16)==27722== ==27722== ----------------------------------------------------------------==27722== ==27722== Possible data race during read of size 4 at 0x601048 by thread #3==27722== Locks held: none==27722== at 0x4006CE: threadfunc(void*) (helgrind.cpp:9)==27722== by 0x4C30EEE: mythread_wrapper (hg_intercepts.c:387)==27722== by 0x4E43EA4: start_thread (in /usr/lib64/libpthread-2.17.so)==27722== by 0x59758DC: clone (in /usr/lib64/libc-2.17.so)==27722== ==27722== This conflicts with a previous write of size 4 by thread #2==27722== Locks held: none==27722== at 0x4006D9: threadfunc(void*) (helgrind.cpp:9)==27722== by 0x4C30EEE: mythread_wrapper (hg_intercepts.c:387)==27722== by 0x4E43EA4: start_thread (in /usr/lib64/libpthread-2.17.so)==27722== by 0x59758DC: clone (in /usr/lib64/libc-2.17.so)==27722== Address 0x601048 is 0 bytes inside data symbol &quot;counter&quot;==27722== ==27722== ----------------------------------------------------------------==27722== ==27722== Possible data race during write of size 4 at 0x601048 by thread #3==27722== Locks held: none==27722== at 0x4006D9: threadfunc(void*) (helgrind.cpp:9)==27722== by 0x4C30EEE: mythread_wrapper (hg_intercepts.c:387)==27722== by 0x4E43EA4: start_thread (in /usr/lib64/libpthread-2.17.so)==27722== by 0x59758DC: clone (in /usr/lib64/libc-2.17.so)==27722== ==27722== This conflicts with a previous write of size 4 by thread #2==27722== Locks held: none==27722== at 0x4006D9: threadfunc(void*) (helgrind.cpp:9)==27722== by 0x4C30EEE: mythread_wrapper (hg_intercepts.c:387)==27722== by 0x4E43EA4: start_thread (in /usr/lib64/libpthread-2.17.so)==27722== by 0x59758DC: clone (in /usr/lib64/libc-2.17.so)==27722== Address 0x601048 is 0 bytes inside data symbol &quot;counter&quot;==27722== counter = 90==27722== ==27722== Use --history-level=approx or =none to gain increased speed, at==27722== the cost of reduced accuracy of conflicting-access information==27722== For lists of detected and suppressed errors, rerun with: -s==27722== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0) 从上述结果知道，valgrind分析出了竞态的情况。 5） Massif 堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。 Massif对内存的分配和释放做profile。程序开发者通过它可以深入了解程序的内存使用行为，从而对内存使用进行优化。这个功能对C++尤其有用，因为C++有很多隐藏的内存分配和释放。 此外，lackey 和 nulgrind 也会提供。Lackey 是小型工具，很少用到；Nulgrind 只是为开发者展示如何创建一个工具。这里就不做介绍了。 参考列表： valgrind的使用 Linux 下利用 valgrind工具进行内存泄露检测和性能分析 valgrind详解与使用实例 使用 Valgrind 检测 C++内存泄漏 利用性能分析工具valgrind+KCachegrind分析 Linux性能分析工具与图形化方法 本文作者：zhuyong 原文链接：https://zhuyongchn.github.io 关于博主：欢迎关注左侧公众号，获取更多干货。 版权声明：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！","categories":[],"tags":[]}],"categories":[],"tags":[]}